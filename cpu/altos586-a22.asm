; ───────────────────────────────────────────────────────────────────────────

CHAN_REGS	struc ;	(sizeof=0x16)
CHAN_PARM	dw ?			; Channel Parameter Register
CHAN_STAT	dw ?			; Channel Status Register
CHAN_CMD	db ?			; Channel Command Register
CHAN_TX_LO	db ?			; Transmit Data	Buffer Address Register	LO
CHAN_TX_MID	db ?			; Transmit Data	Buffer Address Register	MID
CHAN_TX_HI	db ?			; Transmit Data	Buffer Address Register	HI
CHAN_TX_LEN	dw ?			; Transmit Data	Buffer Length Register
CHAN_RX_LO	db ?			; Receive Data Buffer Address Register LO
CHAN_RX_MID	db ?			; Receive Data Buffer Address Register MID
CHAN_RX_HI	db ?			; Receive Data Buffer Address Register HI
CHAN_RX_LEN	dw ?			; Receive Data Buffer Length Register
CHAN_RX_IN	dw ?			; Receive Buffer Input Pointer Register
CHAN_RX_OUT	dw ?			; Receive Buffer Output	Pointer	Register
CHAN_RX_TTY	db ?			; TTY Receive Register
CHAN_RATE	dw ?			; Selectable Rate Register
CHAN_REGS	ends

; ───────────────────────────────────────────────────────────────────────────

IOP8089_SCP	struc ;	(sizeof=0x6)
BUS_TYPE	db ?			; 1 = 16-bit, 0	= 8-bit
_UNUSED		db ?
SCB_OFF		dw ?
SCB_SEG		dw ?
IOP8089_SCP	ends

; ───────────────────────────────────────────────────────────────────────────

IOP8089_SCB	struc ;	(sizeof=0x6)
SOC		db ?
_UNUSED		db ?
CB_OFF		dw ?
CB_SEG		dw ?
IOP8089_SCB	ends

; ───────────────────────────────────────────────────────────────────────────

IOP8089_CB	struc ;	(sizeof=0x8)
CCW		db ?
BUSY		db ?
PB_OFF		dw ?
PB_SEG		dw ?
_UNUSED		dw ?
IOP8089_CB	ends

; ───────────────────────────────────────────────────────────────────────────

HD_PARM_BLOCK	struc ;	(sizeof=0x10)
CMD		db ?
STAT		db ?
CYL_LO		db ?
CYL_HI		db ?
HEAD_DRV	db ?
SEC		db ?
BYTECNT_LO	db ?
BYTECNT_HI	db ?
BUF_OFF_LO	db ?
BUF_OFF_HI	db ?
BUF_SEG_LO	db ?
BUG_SEG_HI	db ?
_RSVD0		db ?
SEC_DONE	db ?
_RSVD1		db ?
JOB_DONE	db ?
HD_PARM_BLOCK	ends

; ───────────────────────────────────────────────────────────────────────────

IOP_BLK		struc ;	(sizeof=0xE)
CMD		db ?
IOP_00_OR_01	db ?
NUM_256B_CHUNKS	db ?
IOP_00_OR_01_B	db ?
COUNTER		db ?
SEC_NUM_PER_512B db ?
SOME_COUNTER	db ?
IOP_5O		db ?
IOP_FF		db ?
STH_LO		db ?
STH_HI		db ?
STH2_LO		db ?
STH2_HI		db ?
STATUS		db ?
IOP_BLK		ends

; ───────────────────────────────────────────────────────────────────────────

FDD_REGS	struc ;	(sizeof=0x10)
FLOPPY_COMMAND_REG db ?
anonymous_0	db ?
FLOPPY_DATA_BUF_PTR dw ?
		db ? ; undefined
		db ? ; undefined
		db ? ; undefined
		db ? ; undefined
		db ? ; undefined
		db ? ; undefined
		db ? ; undefined
		db ? ; undefined
SECTOR_SIZE	dw ?			; base 10
field_E		db ?
field_F		db ?
FDD_REGS	ends

; ───────────────────────────────────────────────────────────────────────────

CPU_REGS	struc ;	(sizeof=0x1C)
SAVE_AX		dw ?
SAVE_BX		dw ?
SAVE_CX		dw ?
SAVE_DX		dw ?
SAVE_SI		dw ?
SAVE_DI		dw ?
SAVE_DS		dw ?
SAVE_ES		dw ?
SAVE_SS		dw ?
SAVE_SP		dw ?
SAVE_BP		dw ?
SAVE_FLAGS	dw ?
SAVE_IP		dw ?
SAVE_CS		dw ?
CPU_REGS	ends

; ───────────────────────────────────────────────────────────────────────────

; Page 6-12
IOPB		struc ;	(sizeof=0x1A)
field_0		dw ?			; Monitor reserved
field_2		dw ?			; Monitor reserved
IOPCODE		db ?
DRIVE		db ?			; Ignored for floppies
TRACK		dw ?
HEAD		db ?
SECTOR		db ?
SECTOR_COUNT	db ?
RETURN_STATUS	db ?
STATUS_MASK	db ?			; Not used?
RETRIES		db ?
BUF_OFFSET	dw ?
BUF_SEGMENT	dw ?
SECTOR_LEN	dw ?			; Ignored for hard drives
field_14	dw ?			; Monitor reserved
field_16	dw ?			; Monitor reserved
field_18	dw ?			; Monitor reserved
IOPB		ends


;
; ╔═════════════════════════════════════════════════════════════════════════╗
; ║	This file is generated by The Interactive Disassembler (IDA)	    ║
; ║	Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>	    ║
; ║			 Licensed to: Freeware version			    ║
; ╚═════════════════════════════════════════════════════════════════════════╝
;
; Input	MD5   :	AF8A8BFBC953DB231C9FFEE7A810BBEA


		.686p
		.mmx
		.model flat

		include	altos586-a22.inc

; ═══════════════════════════════════════════════════════════════════════════

; Segment type:	Regular
ZERO		segment	byte public '' use16
		assume cs:ZERO
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
INT0_OFF	dw ?			; DATA XREF: POST+B8w POST:loc_FE0D1w	...
INT0_SEG	dw ?
word_4		dw ?
word_6		dw ?
INT2_NMI_OFF	dw ?			; DATA XREF: POST+17Ew	POST+244w ...
INT2_NMI_SEG	dw ?			; DATA XREF: POST+182w	POST+248w ...
byte_C		db 78h dup(   ?)
INT33_TIMER_OFF	dw ?			; DATA XREF: POST+250w
INT33_TIMER_SEG	dw ?			; DATA XREF: POST+254w
INT34_IR2_HDD_OFF dw ?			; DATA XREF: POST_FINISH+22w
					; POST_FINISH+43r ...
INT34_IR2_HDD_SEG dw ?			; DATA XREF: SETUP_IRQS+13w
		db 10h dup(   ?)
INT39_IR7_FDD_OFF dw ?			; DATA XREF: SETUP_IRQS+1Bw
INT39_IR7_FDD_SEG dw ?			; DATA XREF: SETUP_IRQS+1Ew
byte_A0		db 360h	dup(   ?)
IOP1_PTR	IOP8089_CB <?>		; DATA XREF: DO_SUBMIT_IOP+250o
					; POST+16Fw ...
IOP3_PTR	IOP8089_CB <?>
SCB		IOP8089_SCB <1,	0, 0, 40h> ; DATA XREF:	POST_FINISH+32o
					; POST_FINISH+39o ...
FW_REG		dw 0			; DATA XREF: POST_FINISH+69o
					; POST_FINISH+7Cw ...
					; SYS -	Firmware Version Register
SYS_STAT_REG	db 0			; SYS -	System Status Register
INT_VECTOR_REG	dw 0			; SYS -	Interrupt Vector Register
NEW_CMD_REG	db 0			; DATA XREF: DO_FLOPPY_CMD+2Dw
					; INC_NEW_CMD_REGw
					; SYS -	New Command Register
IO_REGS		CHAN_REGS <7EB4h, 0, 0,	0, 0, 0, 0, 0A0h, 9, 0,	0Ah, 0,	0, 0, 0>
					; DATA XREF: POST_FINISH+89o
					; CHANNEL_0_INIT+Ao ...
					; CH 0 - Channel Parameter Register
		CHAN_REGS <0FEB4h, 0, 0, 0, 0, 0, 0, 0AAh, 9, 0, 0Ah, 0, 0, 0, 0> ; CH 1 - Channel Parameter Register
		CHAN_REGS <0FEB4h, 0, 0, 0, 0, 0, 0, 0B4h, 9, 0, 0Ah, 0, 0, 0, 0> ; CH 2 - Channel Parameter Register
		CHAN_REGS <0FEB4h, 0, 0, 0, 0, 0, 0, 0BEh, 9, 0, 0Ah, 0, 0, 0, 0> ; CH 3 - Channel Parameter Register
		CHAN_REGS <0FEB4h, 0, 0, 0, 0, 0, 0, 0C8h, 9, 0, 0Ah, 0, 0, 0, 0> ; CH 4 - Channel Parameter Register
		CHAN_REGS <0FEB4h, 0, 0, 0, 0, 0, 0, 0D2h, 9, 0, 0Ah, 0, 0, 0, 0> ; CH 5 - Channel Parameter Register
FDC_REGS	db 0			; FLOPPY_COMMAND_REG ; DATA XREF: DO_FLOPPY_CMD+28w
					; DO_FLOPPY_CMD:POLL_FLOPPY_COMMAND_DONEr ...
		db 0			; anonymous_0 ;	UNK - Command Register?
		dw 0			; FLOPPY_DATA_BUF_PTR
		db 0, 2, 5 dup(0), 2
		dw 512			; SECTOR_SIZE
		db 6			; field_E
		db 0			; field_F
		FDD_REGS <0>
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    2
		db    0
		db    2
		db    6
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db  11h
		db  11h
		db  11h
		db  11h
		db  22h	; "
		db  22h	; "
		db  22h	; "
		db  22h	; "
INT34_IR2_HDD_PTR db 0			; DATA XREF: POST_FINISH+1Fr
					; POST_FINISH+46w ...
		db    0
IOP_IRQ_DOORBELL db 0FFh		; DATA XREF: INT34_IR2_HDD_HANDLER_SIMPLE+6w
					; DO_SUBMIT_IOP+A0w ...
					; IR2/IR7 "Hard/Floppy Disk Interrupt" zero this out
FDD_DOORBELL	db 0			; DATA XREF: DO_SUBMIT_IOP+8Cw
					; INT39_IR7_FDD_HANDLER+6r ...
POST_STATUS_01	db 0			; DATA XREF: POST_FINISH+A1w
					; POST_FINISH+CFw ...
POST_STATUS_02	db 0			; DATA XREF: POST_FINISH+D4w
					; sub_FD024r
IOP_00_OPCODE	db 0			; DATA XREF: DO_SUBMIT_IOP:FDD_HANDLE_CMD_10w
					; DO_SUBMIT_IOP+A9o ...
					; HD/FD	- command
IOP_01_BUSY	db    0			; DATA XREF: DO_SUBMIT_IOP+7Cw
					; DO_SUBMIT_IOP+96r ...
					; HD/FD	- busy status
IOP_02		db    0			; DATA XREF: DO_SUBMIT_IOP+83w
					; DO_SUBMIT_IOP+FAw ...
					; FDD -	read/write track
					; HDD -	read/write track LO
					; FDD -	format sector side (01/02)
IOP_03		db    0			; DATA XREF: DO_SUBMIT_IOP+102w
					; DO_SUBMIT_IOP+16Dw ...
					; FDD -	read/write head/side
					; HDD -	read/write track HI
					; FDD -	format sectors per track
IOP_04_SECTOR	db    0			; DATA XREF: DO_SUBMIT_IOP+10Aw
					; DO_SUBMIT_IOP+172w ...
					; FDD -	read/write start sector
					; HDD -	read/write sector
					; FDD -	format tracks
IOP_05		db    0			; DATA XREF: DO_SUBMIT_IOP+116w
					; DO_SUBMIT_IOP+125w ...
					; FDD read/write - Sector size 02 = 512, 01 = 256
					; HDD read/write - Sector count
					; FDD format - Fill byte E5h
IOP_06		db    0			; DATA XREF: DO_SUBMIT_IOP+137w
					; DO_SUBMIT_IOP+235w
					; FDD -	end sector
					; HDD -	head | 0x80
IOP_07		db    0			; DATA XREF: DO_SUBMIT_IOP+13Bw
					; DO_SUBMIT_IOP+151w
					; FDD -	read/write always 50
IOP_08_FDD_50	db    0			; DATA XREF: DO_SUBMIT_IOP+140w
					; FDD -	read/write always ff (HDD unused)
IOP_09_OFF_HI	db    0			; DATA XREF: DO_SUBMIT_IOP+Ew
					; FD/HD	- Destination offset HI
IOP_0A_OFF_LO	db    0			; DATA XREF: DO_SUBMIT_IOP+18w
					; FD/HD	- Destination offset LO
IOP_0B_SEF_HI	db    0			; DATA XREF: DO_SUBMIT_IOP+22w
					; FD/HD	- Destination segment HI
IOP_0C_SEG_LO	db    0			; DATA XREF: DO_SUBMIT_IOP+2Cw
					; FD/HD	- Destination segment LO
IOP_0D_STATUS	db    0			; DATA XREF: DO_SUBMIT_IOP+30w
					; DO_SUBMIT_IOP+91w ...
					; FD/HD	- Operation status. (FF=not run, 00=success)
		db    0
		db    0
byte_508	db 0			; DATA XREF: POST+2D5r
		db    0
		db    0
		db    0
		db    0
		db    0
INIT_REG_PTR	dd 1FFF000Ch		; DATA XREF: POST_FINISH:LOAD_INIT_REGr
					; F00_AUTO_BOOT+18r
					; 1FFF:000C = 0x1fffc
byte_512	db 2			; DATA XREF: CHANNEL_IO+58w
					; CHANNEL_IO+5Cr ...
aMonitorVersionA2_2 db 0Ah		; DATA XREF: DO_AUTO_BOOT:loc_FCF45o
		db 'Monitor Version a2.2',0
aPassedPowerUpTest db 0Ah		; DATA XREF: POST_FINISH:POST_PASSEDo
		db 'PASSED POWER-UP TEST',0
aFailedPowerUpTest db 0Ah		; DATA XREF: POST_FAILED+1Eo
		db 'FAILED POWER-UP TEST '
FAILED_TEST_NUMBER db 0,0,0		; DATA XREF: POST_FAILED+11o
aBootFailedStatus db 0Ah		; DATA XREF: BOOT_FAILED:loc_FC681o
		db 'Boot Failed, Status=',0
aFloppyCommandNotSupport db 0Ah		; DATA XREF: DO_SUBMIT_IOP:FDD_CMD_NOT_SUPPo
		db 'Floppy command not supported.',0
aFloppyTimeoutError db 0Ah		; DATA XREF: DO_SUBMIT_IOP+1A4o
		db 'Floppy timeout error',0
aHardDiskCommandNotSuppo db 0Ah		; DATA XREF: DO_SUBMIT_IOP:HDD_COMMAND_NOT_SUPPo
		db 'Hard disk command not supported.',0
aHardDiskTimeoutError db 0Ah		; DATA XREF: DO_SUBMIT_IOP+27Fo
		db 'Hard disk timeout error',0
aBreak_____0	db 0Ah			; DATA XREF: BREAKPOINT+8o
		db 'Break ....',0
aCopyrightAltosComputerS db 'COPYRIGHT ALTOS COMPUTER SYSTEMS',0
aChannelNo_04_0	db 0Ah			; DATA XREF: CHANNEL_IO:loc_FCD98o
		db 'Channel no.(0-4): ',0
aReady_0	db ' Ready- ',0         ; DATA XREF: CHANNEL_IO+72o
aDone_0		db ' -Done',0           ; DATA XREF: CHANNEL_IO:loc_FCEEBo
		db    0
byte_630	db 0			; DATA XREF: sub_FD554+3Br
					; sub_FD554+B6w
		db    0
word_632	dw 0			; DATA XREF: sub_FD554+63r
word_634	dw 0			; DATA XREF: sub_FD554+81r
		db 2Ah dup(0)
REG_NAMES	db 'AX'                 ; DATA XREF: DUMP_REGS+4Eo
					; DO_DUMP_REGISTERS+2Cr
aBx_0		db 'BX'
aCx_0		db 'CX'
aDx_0		db 'DX'
aSi_0		db 'SI'
aDi_0		db 'DI'
aDs_0		db 'DS'
aEs_0		db 'ES'
aSs_0		db 'SS'
aSp_0		db 'SP'
aBp_0		db 'BP'
aFl_0		db 'FL'
BOOT_SECTOR_BUF	db  51h, 30h,0D0h,0FFh,0AAh,0BBh,   4, 20h, 0Ah, 4Eh,	6
					; DATA XREF: IOP8089_CMD+5o
					; DO_DISK_BOOT+59o ...
		db  80h,   2, 93h,   8,	  2,0CEh,   2,0EAh,0BAh,   6,0FCh ; While overlaying the IO progrem this RAM area does not
		db  0Ah, 4Eh,	6, 20h,	13h, 4Fh, 14h,	 0,   0, 0Ah,0BEh ; seem to be passed to the IOP. Instead, it is used as a
		db    6,0FCh, 12h,0BAh,	  4,0E2h,   0, 0Ah,0CBh,   4, 0Fh ; buffer to read the boot sectors in from the	FD & HD.
		db  12h,0E7h,	4,0B1h,	  0,   2, 93h,	 8,   2,0CEh,	2
		db 0EAh,0BAh,	6,0FCh,	  2, 93h, 14h,	 0,0CEh,   2, 93h
		db  15h,   0,0CEh,   2,	93h,   6,   2,0CEh,   4,   2, 93h
		db    7,   2,0CEh,   4,	0Ah, 4Eh,   6, 10h,   3, 93h,	6
		db    3,0CFh, 14h, 0Ah,0BEh,   6,0FCh, 2Ah,0BAh,   4,0FCh
		db  0Ah,0E7h, 10h, 7Bh,	0Ah,0BFh,   4, 0Eh,   3, 8Bh, 0Ch
		db  31h, 30h,	0,   0,	63h, 83h, 0Ah, 8Bh, 9Fh, 16h, 70h
		db  31h, 30h,	0,   0,0F1h, 30h, 80h,0FEh, 11h, 30h,0D0h
		db 0FFh, 13h, 4Fh, 12h,	  0,   2, 0Ah,0BBh,   4, 12h,0D1h
		db  30h, 28h, 8Ah,0A0h,	  0, 6Ah,0BBh,	 4, 17h, 13h, 4Fh
		db  12h,   5,	2, 88h,	20h, 0Fh,0D1h, 30h, 28h, 56h,0C0h
		db    0, 4Ah,0BBh,   4,	  5, 13h, 4Fh, 12h,   4,   0, 63h
		db  83h, 12h,	2, 93h,	  9,   0,0CEh, 60h,   0,   2, 93h
		db    4,   2,0CEh,   6,	0Ah,0B6h,   6, 33h,   2,0EFh, 10h
		db  0Ah,0E7h, 10h,   6,	  2,0EBh,   9, 88h, 20h,0DFh, 0Ah
		db 0BBh,   4, 0Eh, 23h,	8Bh, 0Ch, 11h, 30h,   0,   0, 63h
		db  83h, 0Ah, 8Bh, 9Fh,	16h,   7, 0Ah, 4Fh,   5,   0, 88h
		db  20h, 26h,0E0h,   0,0D1h, 30h,   8,0C2h, 60h,   0,	0
		db    0, 83h, 8Fh, 16h,	  2, 92h,   6,	 2,0CFh,   5, 0Ah
		db 0CBh,   5, 7Eh,0E2h,0F7h,   5, 0Ah, 4Eh,   6,   0, 88h
		db  20h,   5, 13h, 4Fh,	  5, 81h,   0, 40h,   0, 20h, 48h
		db 0FFh,0FFh,	0,   0,	  0,   0,   0,	 0,   0,   0,	0
		db    0,   0,	0,   0,	  0,   0,   0,	 0,   0,   0,	0
		db    0,   0,	0,   0,	  0,   0,   0,	 0,   0,   0,	0
		db    0,   0,	0,   0,	  0,   0,   0,	 0,   0,   0,	0
		db    0,   0,	0,   0,	  0,   0,   0,	 0,   0,   0,	0
		db    0,   0,	0,   0,	  0,   0,   0,	 0,   0,   0,	0
		db    0,   0,	0,   0,	  0,   0,   0,	 0,   0,   0,	0
		db    0,   0,	0,   0,	  0,   0,   0,	 0,   0,   0,	0
		db    0,   0,	0,   0,	  0,   0,   0,	 0,   0,   0,	0
		db    0,   0,	0,   0,	  0,   0,   0,	 0,   0,   0,	0
		db    0,   0,	0,   0,	  0,   0,   0,	 0,   0,   0,	0
		db    0,   0,	0,   0,	  0,   0,   0,	 0,   0,   0,	0
		db    0,   0,	0,   0,	  0,   0,   0,	 0,   0,   0,	0
		db    0,   0,	0,   0,	  0,   0,   0,	 0,   0,   0,	0
		db    0,   0,	0,   0,	  0,   0,   0,	 0,   0,   0,	0
		db    0,   0,	0,   0,	  0,   0,   0,	 0,   0,   0,	0
		db    0,   0,	0,   0,	  0,   0,   0,	 0,   0,   0,	0
		db    0,   0,	0,   0,	  0,   0,   0,	 0,   0,   0,	0
		db    0,   0,	0,   0,	  0,   0,   0,	 0,   0,   0,	0
		db    0,   0,	0,   0,	  0,   0,   0,	 0,   0,   0,	0
		db    0,   0,	0,   0,	  0,   0,   0,	 0,   0,   0,	0
		db    0,   0,	0,   0,	  0,   0
aPressAnyKeyToInterruptB db 0Ah		; DATA XREF: DO_AUTO_BOOT:loc_FCF59o
		db 'Press any key to interrupt boot',0Ah,0
aBootingFromHardDisk db	0Ah		; DATA XREF: DO_AUTO_BOOT+75o
		db 'Booting from Hard Disk',0
BOOT_PROMPT	db 0Ah			; DATA XREF: DO_AUTO_BOOT:loc_FCFD0o
		db 'Enter [1] to boot from Hard Disk',0Ah
		db 'Enter [2] to boot from Floppy Disk',0Ah
		db 'Enter [3] to enter Monitor',0Ah
		db 0Ah
		db 'Enter option: ',0
PROMPT_STR	db 0Ah			; DATA XREF: PROMPT_AND_DISPATCHo
		db '< A, B, D, G, I, K, L, M, O, R, S, X > ',0
		db    0
aCsIp_0		db 0Ah			; DATA XREF: DUMP_REGS+Co
		db 'CS:IP ',0
aFlags_0	db '  Flags  ',0        ; DATA XREF: DUMP_REGS+34o
DATA_RAM_END	db    ?	;		; DATA XREF: POST_FINISH+36o
		db    ?	;
FLOPPY_BUF	db    ?	;		; DATA XREF: DO_FLOPPY_CMD+22o
		db    ?	;
		db    ?	;
		db    ?	;
STR_BUFS	db 3Ch dup(?)		; DATA XREF: CHANNEL_TX+35o
CH0_RX_BUF	db 0Ah dup(   ?)
CH1_RX_BUF	db 0Ah dup(   ?)
CH2_RX_BUF	db 0Ah dup(   ?)
CH3_RX_BUF	db 0Ah dup(   ?)
CH4_RX_BUF	db 0Ah dup(   ?)
CH5_RX_BUF	db 0Ah dup(   ?)
		db 546h	dup(?)
word_F22	dw ?			; DATA XREF: CHANNEL_IO+95w
					; sub_FDC06+Cr	...
word_F24	dw ?			; DATA XREF: CHANNEL_IO+9Bw
					; CHANNEL_IO:loc_FCE14w ...
word_F26	dw ?			; DATA XREF: CHANNEL_IO+7Cw
					; CHANNEL_IO+86r ...
word_F28	dw ?			; DATA XREF: CHANNEL_IO:loc_FCE36w
					; CHANNEL_IO+160r ...
COMMAND_CHAR	db ?			; DATA XREF: sub_FC69A+12w
					; sub_FC69A+15r ...
SAVE_SS		dw ?			; DATA XREF: SYSCALL+Bw RESTORE_RETFr
SAVE_SP		dw ?			; DATA XREF: SYSCALL+Fw
					; RESTORE_RETF+4r
SAVE_ES		dw ?			; DATA XREF: SYSCALL+5w
					; RESTORE_RETF+8r ...
word_F31	dw ?			; DATA XREF: POST_FINISH:loc_FC06Dw
					; F10_GET_CONSOLE+3r ...
STATUS		db ?			; DATA XREF: LOW_INIT+14w LOW_INIT+1Fw ...
BOOTCODE	db ?			; DATA XREF: F11_GET_BOOTCODEr
					; DO_DISK_BOOT:COMMON_0w
REGISTERS	CPU_REGS <?>		; DATA XREF: F00_AUTO_BOOT+Bo
					; RESTORE_REGS+13o ...
SYSCALL_ARG_SEG	dw ?			; DATA XREF: F08_09_DISK_IOPB+7w
					; sub_FCA34+Cw	...
SYSCALL_ARG_OFF	dw ?			; DATA XREF: F08_09_DISK_IOPB+3w
					; DO_DISK_IOPB+18w ...
IOP8089_CPB	db ?			; 0 ; DATA XREF: IOP8089_CMD+1o
		db ?			; 1 ; Command Parameter	Block
		db ?			; 2
		db ?			; 3
		db ?			; 4
		db ?			; 5
		db ?			; 6
		db ?			; 7
		db ?			; 8
		db ?			; 9
		db ?			; 10
		db ?			; 11
		db ?			; 12
		db ?			; 13
		db ?			; 14
		db ?			; 15
		db ?			; 16
		db ?			; 17
		db ?			; 18
		db ?			; 19
		db ?			; 20
		db ?			; 21
		db ?			; 22
		db ?			; 23
		db    ?	;
		db    ?	;
BOOT_IOPB	IOPB <?>		; DATA XREF: DO_DISK_IOPB+14w
					; DO_DISK_BOOT:COMMON_1w ...
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
ZERO		ends

; ───────────────────────────────────────────────────────────────────────────
; ═══════════════════════════════════════════════════════════════════════════

; Segment type:	Pure code
ROM		segment	byte public 'CODE' use16
		assume cs:ROM
		assume es:ZERO,	ss:ZERO, ds:ZERO, fs:ZERO, gs:ZERO

SYSCALL_TRAMPOLINE:			; CODE XREF: SYSCALL_ENTRYJ
		jmp	SYSCALL

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


ENTRY_TRAMPOLINE proc near		; CODE XREF: HIGH:FFF0J
		jmp	ENTRY
ENTRY_TRAMPOLINE endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: thunk

LOW_INIT_TRAMPOLINE proc near		; CODE XREF: POST:GO_LOW_INITJ
		jmp	LOW_INIT	; BL = status
LOW_INIT_TRAMPOLINE endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: thunk

SETUP_INTC1_TRAMPOLINE_2 proc near	; CODE XREF: IOP_SEND+1p
		jmp	far ptr	SETUP_INTC1_TRAMPOLINE
SETUP_INTC1_TRAMPOLINE_2 endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: thunk

POKE_IOP1_TRAMPOLINE2 proc near		; CODE XREF: ENTRY+13j
		jmp	far ptr	POKE_IOP1_TRAMPOLINE
POKE_IOP1_TRAMPOLINE2 endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


ENTRY		proc near		; CODE XREF: ENTRY_TRAMPOLINEj
		cli

loc_FC014:				; Clear	violation port
		in	ax, 70h

loc_FC016:				; Error	address	2
		in	ax, 60h

loc_FC018:
		and	ax, 200h
		mov	bh, ah
		shr	ax, 1
		out	58h, ax		; Control bits port
		cmp	bh, 2
		jnz	short loc_FC029
		jmp	POKE_IOP1_TRAMPOLINE2
; ───────────────────────────────────────────────────────────────────────────

loc_FC029:				; CODE XREF: ENTRY+11j
		jmp	far ptr	POST_TRAMPOLINE
ENTRY		endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; BL = status

LOW_INIT	proc near		; CODE XREF: LOW_INIT_TRAMPOLINEj
					; ERR_STAT_0A+2j
		lea	di, RETURN	; Can't use statck because we're
					; changing memory mapping
		jmp	INIT_MEMORY_MAPPING
; ───────────────────────────────────────────────────────────────────────────

RETURN:					; DATA XREF: LOW_INITo
		in	ax, 60h		; MMU Error Address 2 -	Read Only
		and	ax, 200h
		shr	ax, 1
		out	58h, ax		; Control Bits Port - Write Only
		xor	ax, ax
		mov	ds, ax
		mov	STATUS,	bl	; BL = POST result
		in	ax, 60h		; MMU Error Address 2 -	Read Only
		and	ah, 2		; Warm boot flag
		jz	short POST_FINISH
		mov	STATUS,	0FFh
LOW_INIT	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


POST_FINISH	proc near		; CODE XREF: LOW_INIT+1Dj SYSCALL+2Dj
		mov	ax, 100h
		out	58h, ax		; Control Bits Port - Write Only
		in	ax, 70h		; MMU Clear Violation Port
		xor	ax, ax
		mov	ds, ax
		lea	di, RET_2	; DI = linkage,	no stack
		jmp	SWITCH_STACK
; ───────────────────────────────────────────────────────────────────────────

RET_2:					; DATA XREF: POST_FINISH+Bo
		mov	dx, 7E00h
		and	ax, ax
		jz	short loc_FC06D
		mov	dh, 0FAh ; '·'

loc_FC06D:				; CODE XREF: POST_FINISH+17j
		mov	word_F31, dx
		mov	al, INT34_IR2_HDD_PTR
		mov	byte ptr INT34_IR2_HDD_OFF, al
		mov	ax, 0FC00h
		assume ds:ROM
		mov	ds, ax
		xor	ax, ax
		mov	es, ax
		lea	si, DATA_ROM	; "\x01@┤~á\t\n┤■¬\t\n┤■┤\t\n┤■¥\t\n┤■╚\t\n┤■Ê\t\n\x02\x02\x02\x06\x02\x02\x06"...
		assume ds:ZERO
		lea	di, SCB
		mov	cx, offset DATA_RAM_END
		sub	cx, offset SCB
		repne movsb		; Copy Data!
		xor	ax, ax
		mov	ds, ax
		mov	al, byte ptr INT34_IR2_HDD_OFF
		mov	INT34_IR2_HDD_PTR, al
		in	ax, 78h		; MMU Violation	Port - Read Only
		and	ah, 10h		; Status bit 0 -- system config. jumper
		jnz	short LOAD_INIT_REG
		cmp	byte ptr word_F31+1, 7Eh ; '~'
		jz	short loc_FC0B1
		mov	SCB.CB_SEG, 0FBFFh
		jmp	short LOAD_INIT_REG
; ───────────────────────────────────────────────────────────────────────────

loc_FC0B1:				; CODE XREF: POST_FINISH+55j
		mov	SCB.CB_SEG, 7FFFh

LOAD_INIT_REG:				; CODE XREF: POST_FINISH+4Ej
					; POST_FINISH+5Dj
		lds	di, INIT_REG_PTR
		mov	word ptr [di], offset FW_REG
		inc	di
		inc	di
		xor	ax, ax
		mov	[di], al
		mov	ds, ax
		mov	es, ax
		mov	ss, ax
		mov	sp, 1000h
		mov	FW_REG,	ax
		out	50h, ax		; Z80A I/O Processor Chan att.
		mov	al, 81h	; 'ü'   ; Sys Command 1 = Enable IOP
		call	SUBMIT_SYS_CMD	; AL = command
		mov	cx, 2
		lea	si, IO_REGS
		cmp	STATUS,	0

loc_FC0E4:				; 7e->fe for channel 1
		jz	short loc_FC0ED
		cmp	STATUS,	10h
		jbe	short loc_FC0F8	; Command 1 = initialize channel

loc_FC0ED:				; CODE XREF: POST_FINISH:loc_FC0E4j
		mov	al, 0FEh ; '■'  ; 7e->fe for channel 1
		inc	si
		mov	[si], al
		dec	si
		mov	POST_STATUS_01,	0

loc_FC0F8:				; CODE XREF: POST_FINISH+99j
		mov	al, 81h	; 'ü'   ; Command 1 = initialize channel

NEXT_CHANNEL:				; CODE XREF: POST_FINISH+AFj
		call	SUMBIT_CHAN_CMD	; SI = channel register	block
					; AL = command

loc_FC0FD:				; Sizeof(SOME_BLOCK)
		add	si, 16h
		loop	NEXT_CHANNEL
		mov	cx, 25

NEXT_NEWLINE_25:			; CODE XREF: POST_FINISH+B9j
		push	cx
		call	NEWLINE
		pop	cx
		loop	NEXT_NEWLINE_25
		cmp	STATUS,	10h
		ja	short DO_FLOPPY_BOOT
		mov	bl, STATUS
		xor	ax, ax
		cmp	bl, al
		jz	short POST_PASSED
		call	POST_FAILED
		mov	POST_STATUS_01,	0FFh
		mov	POST_STATUS_02,	0FFh

loc_FC12B:
		jmp	short DO_FLOPPY_BOOT
; ───────────────────────────────────────────────────────────────────────────

POST_PASSED:				; CODE XREF: POST_FINISH+CAj
		lea	dx, aPassedPowerUpTest ; "\nPASSED POWER-UP TEST"
		push	dx
		call	PRINT_STRING
		add	sp, 2
		jmp	short DO_FLOPPY_BOOT
POST_FINISH	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

POST_FAILED	proc near		; CODE XREF: POST_FINISH+CCp
					; sub_FD024+7p
		push	bp
		mov	bp, sp
		push	ax
		push	bx
		push	dx
		mov	bl, STATUS
		mov	bh, 0
		mov	POST_STATUS_01,	0
		lea	dx, FAILED_TEST_NUMBER ; ""
		push	dx		; Target buffer
		push	dx		; ...why twice?
		push	bx		; Number
		call	FORMAT_HEX_NUMBER
		add	sp, 6
		lea	dx, aFailedPowerUpTest ; "\nFAILED POWER-UP TEST "
		push	dx
		call	PRINT_STRING
		add	sp, 2
		pop	dx
		pop	bx
		pop	ax
		pop	bp
		retn
POST_FAILED	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


DO_FLOPPY_BOOT	proc near		; CODE XREF: POST_FINISH+C0j
					; POST_FINISH:loc_FC12Bj ...
		xor	ax, ax
		push	ax
		push	ax
		call	DO_FLOPPY_CMD
		add	sp, 4
		cmp	STATUS,	0FEh ; '■'
		jz	short near ptr RESTORE_RETF
DO_FLOPPY_BOOT	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


F00_AUTO_BOOT	proc far		; CODE XREF: SYSCALL+32p
					; DATA XREF: ROM:FUNC_TABLEo
		xor	ax, ax
		mov	ds, ax
		mov	es, ax

loc_FC17F:
		mov	ss, ax
		mov	sp, 1000h
		lea	di, REGISTERS
		mov	cx, 14		; sizeof(REGISTERS)
		rep stosw
		mov	REGISTERS.SAVE_SP, sp
		push	word ptr INIT_REG_PTR
		sti
		call	DO_AUTO_BOOT
F00_AUTO_BOOT	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


SYSCALL		proc near		; CODE XREF: ROM:SYSCALL_TRAMPOLINEj
		push	ds
		xor	ax, ax
		mov	ds, ax
		mov	SAVE_ES, es
		mov	es, ax
		assume es:ROM
		mov	SAVE_SS, ss
		mov	SAVE_SP, sp
		mov	ss, ax
		mov	sp, 1000h
		xor	bh, bh
		cmp	bl, 0Fh
		ja	short near ptr RESTORE_RETF
		jnz	short RUN_SYSCALL_HANDLER
		lea	di, RET_3
		jmp	INIT_MEMORY_MAPPING
; ───────────────────────────────────────────────────────────────────────────

RET_3:					; DATA XREF: SYSCALL+21o
		mov	STATUS,	0FEh ; '■'
		jmp	POST_FINISH
; ───────────────────────────────────────────────────────────────────────────

RUN_SYSCALL_HANDLER:			; CODE XREF: SYSCALL+1Fj
		shl	bx, 1
		call	cs:FUNC_TABLE[bx]
SYSCALL		endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


RESTORE_RETF	proc far		; CODE XREF: DO_FLOPPY_BOOT+Fj
					; SYSCALL+1Dj
		mov	ss, SAVE_SS
		mov	sp, SAVE_SP
		mov	es, SAVE_ES
		assume es:ZERO
		pop	ds
		retf
RESTORE_RETF	endp ; sp =  2

; ───────────────────────────────────────────────────────────────────────────
		retn
; ───────────────────────────────────────────────────────────────────────────
FUNC_TABLE	dw offset F00_AUTO_BOOT	; DATA XREF: SYSCALL+32r
		dw offset F01_05_IO_CHANNEL_STATUS
		dw offset F02_IO_GETCHAR
		dw offset F03_IO_PUTCHAR
		dw offset F04_IO_SETATTR
		dw offset F01_05_IO_CHANNEL_STATUS
		dw offset F06_IO_NEWLINE
		dw offset F07_IO_PUTS
		dw offset F08_09_DISK_IOPB
		dw offset F08_09_DISK_IOPB
		dw offset F10_GET_CONSOLE
off_FC1F5	dw offset F11_GET_BOOTCODE
		dw offset F12_DISK_BOOT
		dw offset F13_RESERVED
		dw offset F14_RESERVED

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

F14_RESERVED	proc near		; CODE XREF: SYSCALL+32p
					; DATA XREF: ROM:01FBo
		push	bp
		mov	bp, sp

loc_FC200:
		call	CHANNEL_IO
		pop	bp
		retn
F14_RESERVED	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


F13_RESERVED	proc near		; CODE XREF: SYSCALL+32p
					; DATA XREF: ROM:01F9o
		and	ch, ch
		jz	short loc_FC20D
		mov	INT34_IR2_HDD_PTR, cl

loc_FC20D:				; CODE XREF: F13_RESERVED+2j
		mov	al, INT34_IR2_HDD_PTR
		retn
F13_RESERVED	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


F01_05_IO_CHANNEL_STATUS proc near	; CODE XREF: SYSCALL+32p
					; DATA XREF: ROM:01E1o	...
		push	bx
		push	cx
		mov	ax, 0FFFFh
		push	ax
		push	cx
		call	CHANNEL_RX
		add	sp, 6
		pop	bx
		cmp	bl, 2
		jz	short locret_FC226
		mov	ax, dx

locret_FC226:				; CODE XREF: F01_05_IO_CHANNEL_STATUS+11j
		retn
F01_05_IO_CHANNEL_STATUS endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


F02_IO_GETCHAR	proc near		; CODE XREF: SYSCALL+32p
					; DATA XREF: ROM:01E3o
		push	cx
		call	DO_GETCHAR
		add	sp, 2
		retn
F02_IO_GETCHAR	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


F03_IO_PUTCHAR	proc near		; CODE XREF: SYSCALL+32p
					; DATA XREF: ROM:01E5o
		mov	STATUS,	dl
		lea	dx, STATUS
		push	dx
		push	cx
		call	DO_PUTCHAR
		add	sp, 4
		retn
F03_IO_PUTCHAR	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


F04_IO_SETATTR	proc near		; CODE XREF: SYSCALL+32p
					; DATA XREF: ROM:01E7o
		push	dx
		mov	ax, 0FFFFh
		push	ax
		push	cx
		call	CHANNEL_TX
		add	sp, 6
		retn
F04_IO_SETATTR	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


F06_IO_NEWLINE	proc near		; CODE XREF: SYSCALL+32p
					; DATA XREF: ROM:01EBo
		push	cx
		call	DO_IO_NEWLINE
		add	sp, 2
		retn
F06_IO_NEWLINE	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


F07_IO_PUTS	proc near		; CODE XREF: SYSCALL+32p
					; DATA XREF: ROM:01EDo
		mov	ax, SAVE_ES
		push	dx
		push	ax
		push	cx
		call	DO_PUTS
		add	sp, 6
		retn
F07_IO_PUTS	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


F08_09_DISK_IOPB proc near		; CODE XREF: SYSCALL+32p
					; DATA XREF: ROM:01EFo	...
		mov	ax, SAVE_ES
		mov	SYSCALL_ARG_OFF, cx
		mov	SYSCALL_ARG_SEG, ax
		call	DO_DISK_IOPB
		retn
F08_09_DISK_IOPB endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


F10_GET_CONSOLE	proc near		; CODE XREF: SYSCALL+32p
					; DATA XREF: ROM:01F3o
		mov	dx, 1FFFh
		mov	ax, word_F31
		mov	SAVE_ES, ax
		xor	ax, ax
		retn
F10_GET_CONSOLE	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


F11_GET_BOOTCODE proc near		; CODE XREF: SYSCALL+32p
					; DATA XREF: ROM:off_FC1F5o
		mov	al, BOOTCODE
		retn
F11_GET_BOOTCODE endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


F12_DISK_BOOT	proc near		; CODE XREF: SYSCALL+32p
					; DATA XREF: ROM:01F7o
		push	cx
		call	DO_DISK_BOOT
		add	sp, 2
		retn
F12_DISK_BOOT	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

IOP_SEND	proc near		; CODE XREF: DO_SUBMIT_IOP+B1p
					; DO_SUBMIT_IOP+254p ...

BLOCK_400	= word ptr  4
IOP_BLOCK_4F8	= word ptr  6
IOPORT_ADDR	= word ptr  8

		sti
		call	SETUP_INTC1_TRAMPOLINE_2
		push	bp
		mov	bp, sp
		push	bx
		push	dx
		push	es
		push	di
		xor	ax, ax
		mov	es, ax
		mov	ax, [bp+BLOCK_400] ; 400
		mov	bx, [bp+IOP_BLOCK_4F8] ; 4f8
		mov	dx, [bp+IOPORT_ADDR]
		mov	di, ax
		mov	es:[di], bx	; 0000:0400 <= 04f8
		inc	di
		inc	di
		mov	word ptr es:[di], ds ; 0000:0402 = 0000
		out	dx, ax		; DX=7000
		pop	di
		pop	es
		pop	dx
		pop	bx
		pop	bp
		retn
IOP_SEND	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Orphan

sub_FC2B1	proc near		; DATA XREF: RESTORE_REGSo
		push	bx
		push	ds
		xor	bx, bx
		mov	ds, bx
		mov	bx, 0F35h
		mov	word ptr [bx+0Eh], es
		mov	[bx+0],	ax
		mov	[bx+4],	cx
		mov	[bx+6],	dx
		mov	[bx+8],	si
		mov	[bx+0Ah], di
		mov	[bx+14h], bp
		mov	word ptr [bx+10h], ss
		pop	ax
		mov	[bx+0Ch], ax
		pop	ax
		mov	[bx+2],	ax
		pop	ax
		mov	[bx+18h], ax
		pop	ax
		mov	[bx+1Ah], ax
		pop	ax
		mov	[bx+16h], ax
		mov	[bx+12h], sp
		xor	ax, ax
		mov	ds, ax
		mov	es, ax
		mov	ss, ax
		mov	sp, 1000h
		test	word ptr [bx+16h], 100h
		jz	short loc_FC309
		and	word ptr [bx+16h], 0FEFFh
		call	DUMP_REGS
		xor	ax, ax
		push	ax
		call	DO_AUTO_BOOT

loc_FC309:				; CODE XREF: sub_FC2B1+48j
		dec	word ptr [bx+18h]
		call	BREAKPOINT
sub_FC2B1	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


SWITCH_STACK	proc near		; CODE XREF: POST_FINISH+Fj POST+DCj ...
		mov	sp, ds
		mov	ax, 8000h
		mov	ds, ax
		assume ds:nothing
		mov	dl, [bx]
		not	byte ptr [bx]
		not	dl
		cmp	dl, [bx]
		not	byte ptr [bx]
		jz	short loc_FC324
		xor	ax, ax

loc_FC324:				; CODE XREF: SWITCH_STACK+11j
		mov	ds, sp
		assume ds:ZERO
		jmp	di
SWITCH_STACK	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Puts 0x21 to BH and 1	to CX to terminate the test loop

INT33_TEST_TIMER_HANDLER proc far	; DATA XREF: POST+24Co
		mov	bh, 21h	; '!'
		mov	cx, 1
INT33_TEST_TIMER_HANDLER endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


DEFAULT_HANDLER	proc far		; DATA XREF: POST+2E4o
		iret
DEFAULT_HANDLER	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


INIT_MEMORY_MAPPING proc near		; CODE XREF: LOW_INIT+4j SYSCALL+25j ...
		mov	dx, 200h
		mov	cl, 0		; -1 = 256 pages

INIT_ONE_PAGE:				; CODE XREF: INIT_MEMORY_MAPPING+Ej
		mov	ah, 0DCh ; '▄'
		mov	al, cl
		out	dx, ax		; MMU Memory Management	Ports
		inc	dx
		inc	dx
		inc	cl
		jnz	short INIT_ONE_PAGE
		jmp	di
INIT_MEMORY_MAPPING endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


INT2_NMI_HANDLER proc far		; DATA XREF: POST+17Ao	POST+240o ...
		push	ax
		in	ax, 78h		; MMU Violation	Port - Read Only
		and	al, 2
		jz	short ERR_STAT_0A
		in	ax, 70h		; MMU Clear Violation Port
		pop	ax
		iret
INT2_NMI_HANDLER endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


INT34_IR2_HDD_HANDLER_SIMPLE proc far	; DATA XREF: SETUP_IRQS+Co
		push	ds
		push	ax
		xor	ax, ax
		mov	ds, ax
		mov	IOP_IRQ_DOORBELL, 0 ; IR2/IR7 "Hard/Floppy Disk	Interrupt" zero	this out
		pop	ax
		pop	ds
		iret
INT34_IR2_HDD_HANDLER_SIMPLE endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


ERR_STAT_0A	proc near		; CODE XREF: INT2_NMI_HANDLER+5j
		mov	bl, 0Ah
		jmp	LOW_INIT	; BL = status
ERR_STAT_0A	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

CHANNEL_0_INIT	proc near		; CODE XREF: DO_AUTO_BOOT+B3p
		push	bp
		mov	bp, sp
		push	si
		push	ax
		push	dx
		xor	ax, ax
		mov	al, 0FEh ; '■'  ; Move to BLOCK[1]
		lea	si, IO_REGS	; 7e ->	Fe for CHANNEL 0
		inc	si
		mov	[si], al
		dec	si
		mov	al, 81h	; 'ü'   ; Command 1 = Init channel
		call	SUMBIT_CHAN_CMD	; SI = channel register	block
					; AL = command
		pop	dx
		pop	ax
		pop	si
		pop	bp
		retn
CHANNEL_0_INIT	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


IOP8089_CMD	proc near		; CODE XREF: DO_AUTO_BOOT:BOOT_CHOICE_HDDp
					; DO_AUTO_BOOT:BOOT_CHOICE_FDDp ...
		push	es
		lea	si, IOP8089_CPB	; Command Parameter Block
		mov	word ptr [si], offset BOOT_SECTOR_BUF ;	While overlaying the IO	progrem	this RAM area does not
					; seem to be passed to the IOP.	Instead, it is used as a
					; buffer to read the boot sectors in from the FD & HD.
		add	word ptr [si], 2BF0h ; ROM_OFFSET
		mov	word ptr [si+2], 0FC00h
		mov	ax, SCB.CB_SEG
		assume es:nothing
		mov	es, ax
		mov	al, 3
		mov	es:0, al
		mov	es:2, si
		mov	word ptr es:4, ds
		mov	byte ptr es:1, 1 ; 0040:0001 CCW - Channel Control Word
		mov	dx, 0FF00h	; I/O Processor	Channel	Attention
		out	dx, al
		mov	cx, 6000	; How long to wait

WAIT_CHANNEL_NO_BUSY:			; CODE XREF: IOP8089_CMD+46j
		cmp	byte ptr es:1, 0 ; 0040:0001 CCW - Channel Control Word
		jz	short WAIT_IOP_DONE
		mov	ax, 1
		push	ax
		call	DELAY		; Time on stack
		add	sp, 2
		loop	WAIT_CHANNEL_NO_BUSY ; 0040:0001 CCW - Channel Control Word

WAIT_IOP_DONE:				; CODE XREF: IOP8089_CMD+3Aj
		pop	es
		assume es:ZERO
		retn
IOP8089_CMD	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

DO_GETCHAR	proc near		; CODE XREF: F02_IO_GETCHAR+1p
					; sub_FCF06+Cp

CHAR		= word ptr -6
IO_CHAN		= byte ptr  4

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 2
		lea	di, [bp+CHAR]
		push	di
		mov	di, 1
		push	di
		mov	al, [bp+IO_CHAN]
		cbw
		push	ax
		call	CHANNEL_RX
		add	sp, 6
		mov	byte ptr [bp+CHAR], al
		mov	al, byte ptr [bp+CHAR]
		cbw

loc_FC3E6:
		jmp	COMMON_RETURN
DO_GETCHAR	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

DO_PUTCHAR	proc near		; CODE XREF: F03_IO_PUTCHAR+Ap

IO_CHAN		= byte ptr  4
CHAR		= word ptr  6

		push	bp
		mov	bp, sp
		push	di
		push	si
		push	[bp+CHAR]
		mov	di, 1
		push	di
		mov	al, [bp+IO_CHAN]
		cbw
		push	ax
		call	PUTS_CONSOLE

loc_FC3FE:
		add	sp, 6
		jmp	COMMON_RETURN
DO_PUTCHAR	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

FORMAT_HEX_NUMBER proc near		; CODE XREF: POST_FAILED+18p
					; PRINT_HEX_STAT+15p

var_16		= byte ptr -16h
var_15		= byte ptr -15h
var_14		= byte ptr -14h
var_13		= byte ptr -13h
var_12		= byte ptr -12h
var_11		= byte ptr -11h
var_10		= byte ptr -10h
var_F		= byte ptr -0Fh
var_E		= byte ptr -0Eh
var_D		= byte ptr -0Dh
var_C		= byte ptr -0Ch
var_B		= byte ptr -0Bh
var_A		= byte ptr -0Ah
var_9		= byte ptr -9
var_8		= byte ptr -8
var_7		= byte ptr -7
NUMBER		= byte ptr  4
BUF_		= word ptr  6
BUF__		= word ptr  8

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 12h
		mov	[bp+var_16], '0'
		mov	[bp+var_15], '1'
		mov	[bp+var_14], '2'
		mov	[bp+var_13], '3'
		mov	[bp+var_12], '4'
		mov	[bp+var_11], '5'
		mov	[bp+var_10], '6'
		mov	[bp+var_F], '7'
		mov	[bp+var_E], '8'
		mov	[bp+var_D], '9'
		mov	[bp+var_C], 'A'
		mov	[bp+var_B], 'B'
		mov	[bp+var_A], 'C'
		mov	[bp+var_9], 'D'
		mov	[bp+var_8], 'E'
		mov	[bp+var_7], 'F'
		push	[bp+BUF_]
		lea	bx, [bp+var_16]
		mov	dl, [bp+NUMBER]
		and	dx, 0F0h
		mov	cx, 4
		sar	dx, cl
		add	bx, dx
		mov	dl, [bx]
		pop	bx
		mov	[bx], dl	; A resulting character
		push	[bp+BUF__]
		lea	bx, [bp+var_16]
		mov	dl, [bp+NUMBER]
		and	dx, 0Fh
		add	bx, dx
		mov	dl, [bx]
		pop	bx
		mov	[bx], dl	; Place	the resulting character
		jmp	COMMON_RETURN
FORMAT_HEX_NUMBER endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Time on stack

DELAY		proc near		; CODE XREF: IOP8089_CMD+40p
					; DO_DISK_BOOT+A0p ...
		push	bx
		mov	bx, sp
		push	cx
		mov	ax, [bx+4]
		or	ax, ax
		jz	short NO_WAIT

OUTER_LOOP:				; CODE XREF: DELAY+16j
		mov	bx, 10

INNTER_LOOP:				; CODE XREF: DELAY+13j
		mov	cl, 120
		shr	cl, cl
		dec	bx
		jnz	short INNTER_LOOP
		dec	ax
		jnz	short OUTER_LOOP

NO_WAIT:				; CODE XREF: DELAY+9j
		pop	cx
		pop	bx
		retn
DELAY		endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

DO_DISK_BOOT	proc near		; CODE XREF: F12_DISK_BOOT+1p
					; DO_AUTO_BOOT+86p ...

DOT		= word ptr -12h
RETRIES		= word ptr -10h
var_E		= word ptr -0Eh
var_C		= word ptr -0Ch
var_A		= word ptr -0Ah
IOP_PROGRAM_RAM_PTR= word ptr -8
var_6		= word ptr -6
DRIVE_NUMBER	= word ptr  4

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 0Eh
		cmp	[bp+DRIVE_NUMBER], 3
		jbe	short IS_FLOPPY_0
		mov	dx, 1
		jmp	short COMMON_0
; ───────────────────────────────────────────────────────────────────────────

IS_FLOPPY_0:				; CODE XREF: DO_DISK_BOOT+Cj
		mov	dx, 2

COMMON_0:				; CODE XREF: DO_DISK_BOOT+11j
		mov	BOOTCODE, dl
		mov	dx, [bp+DRIVE_NUMBER]
		mov	BOOT_IOPB.DRIVE, dl
		cmp	[bp+DRIVE_NUMBER], 3
		jbe	short IS_FLOPPY_1
		mov	dx, 21h	; '!'
		jmp	short COMMON_1
; ───────────────────────────────────────────────────────────────────────────

IS_FLOPPY_1:				; CODE XREF: DO_DISK_BOOT+25j
		mov	dx, 20h	; ' '

COMMON_1:				; CODE XREF: DO_DISK_BOOT+2Aj
		mov	BOOT_IOPB.IOPCODE, dl
		mov	BOOT_IOPB.TRACK, 0
		mov	BOOT_IOPB.HEAD,	0
		cmp	[bp+DRIVE_NUMBER], 3
		jbe	short loc_FC4E0
		sub	dx, dx
		jmp	short loc_FC4E3
; ───────────────────────────────────────────────────────────────────────────

loc_FC4E0:				; CODE XREF: DO_DISK_BOOT+42j
		mov	dx, 1

loc_FC4E3:				; CODE XREF: DO_DISK_BOOT+46j
		mov	BOOT_IOPB.SECTOR, dl
		mov	BOOT_IOPB.SECTOR_COUNT,	1
		mov	BOOT_IOPB.RETRIES, 10
		mov	BOOT_IOPB.BUF_OFFSET, offset BOOT_SECTOR_BUF ; While overlaying	the IO progrem this RAM	area does not
					; seem to be passed to the IOP.	Instead, it is used as a
					; buffer to read the boot sectors in from the FD & HD.

loc_FC4F7:
		mov	BOOT_IOPB.BUF_SEGMENT, 0
		mov	BOOT_IOPB.SECTOR_LEN, 512
		cmp	[bp+DRIVE_NUMBER], 3
		jbe	short IS_FLOPPY
		mov	[bp+RETRIES], 10
		mov	[bp+DOT], '.'

TRY_SUBMIT_IOP:				; CODE XREF: DO_DISK_BOOT+B0j
		mov	di, 1
		call	RUN_IOP
		cmp	BOOT_IOPB.RETURN_STATUS, 0
		jz	short IOP_STATUS_00_GOOD
		mov	BOOT_IOPB.RETRIES, 10
		cmp	[bp+RETRIES], 0
		jnz	short MORE_RETRIES

BOOT_BAD:				; CODE XREF: DO_DISK_BOOT+BAj
					; DO_DISK_BOOT+F7j ...
		call	BOOT_FAILED
		jmp	loc_FC679
; ───────────────────────────────────────────────────────────────────────────

MORE_RETRIES:				; CODE XREF: DO_DISK_BOOT+91j
		dec	[bp+RETRIES]
		mov	di, 1000
		push	di
		call	DELAY		; Time on stack
		add	sp, 2
		lea	di, [bp+DOT]
		push	di
		call	PUTCHAR_CONSOLE
		add	sp, 2
		jmp	short TRY_SUBMIT_IOP
; ───────────────────────────────────────────────────────────────────────────

IS_FLOPPY:				; CODE XREF: DO_DISK_BOOT+6Fj
		call	RUN_IOP
		cmp	BOOT_IOPB.RETURN_STATUS, 0
		jnz	short BOOT_BAD

IOP_STATUS_00_GOOD:			; CODE XREF: DO_DISK_BOOT+86j
		mov	dl, BOOT_SECTOR_BUF+3 ;	Boot segment LO
		sub	dh, dh
		mov	al, BOOT_SECTOR_BUF+4 ;	Boot segment HI
		cbw
		mov	cx, 8
		shl	ax, cl
		add	dx, ax
		mov	[bp+var_A], dx
		mov	[bp+var_C], 0
		mov	REGISTERS.SAVE_CS, dx
		mov	di, [bp+var_C]
		mov	REGISTERS.SAVE_IP, di
		mov	[bp+var_6], 0
		mov	di, [bp+var_A]
		mov	BOOT_IOPB.BUF_SEGMENT, di
		inc	BOOT_IOPB.SECTOR
		mov	al, BOOT_SECTOR_BUF+9 ;	Boot type.
		cbw
		cmp	ax, 2
		ja	short BOOT_BAD
		shl	ax, 1
		xchg	ax, bx
		jmp	cs:BOOT_TYPE_HANDLERS[bx] ; Handle OASIS boot.
DO_DISK_BOOT	endp			; Doesn't seem to be actually used.
					; OASIS	is a system that runs on Z80 anyways.

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Handle CP/M boot. Doesn't seem to be actually used.
; Actualy CP/M images use XENIX	style boot (type 0x02)

BOOT_TYPE_00_CMP86 proc	near		; DATA XREF: ROM:BOOT_TYPE_HANDLERSo
		mov	word ptr [bp-8], (offset BOOT_SECTOR_BUF+80h) ;	While overlaying the IO	progrem	this RAM area does not
					; seem to be passed to the IOP.	Instead, it is used as a
					; buffer to read the boot sectors in from the FD & HD.
		mov	di, 180h
		push	di
		lea	di, [bp-0Ch]
		push	di
		lea	di, [bp-8]
		push	di
		call	sub_FD140
		add	sp, 6
		mov	di, [bp-0Ch]
		add	di, 180h
		mov	BOOT_IOPB.BUF_OFFSET, di
		cmp	word ptr [bp+4], 3
		ja	short loc_FC62D

loc_FC5C1:
		mov	BOOT_IOPB.SECTOR_COUNT,	8
		call	RUN_IOP
		mov	al, BOOT_IOPB.SECTOR_COUNT
		cbw
		mov	cx, 9
		shl	ax, cl
		add	BOOT_IOPB.BUF_OFFSET, ax
		mov	BOOT_IOPB.HEAD,	1

loc_FC5DB:
		mov	BOOT_IOPB.SECTOR, 1
		mov	BOOT_IOPB.SECTOR_COUNT,	9
		jmp	AFTER_JUMP_TABLE
BOOT_TYPE_00_CMP86 endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Handle OASIS boot.
; Doesn't seem to be actually used.
; OASIS	is a system that runs on Z80 anyways.

BOOT_TYPE_01_OASIS proc	near		; CODE XREF: DO_DISK_BOOT+FCj
					; DATA XREF: ROM:065Fo
		mov	word ptr [bp-0Eh], 502
		cmp	word ptr [bp+4], 3
		ja	short loc_FC60D
		mov	di, 1
		push	di
		mov	al, BOOT_IOPB.DRIVE
		cbw
		push	ax
		call	DO_FLOPPY_CMD
		add	sp, 4
		mov	BOOT_IOPB.SECTOR_LEN, 256

loc_FC608:
		mov	word ptr [bp-0Eh], 246

loc_FC60D:				; CODE XREF: BOOT_TYPE_01_OASIS+9j
		mov	word ptr [bp-8], (offset BOOT_SECTOR_BUF+0Ah) ;	While overlaying the IO	progrem	this RAM area does not
					; seem to be passed to the IOP.	Instead, it is used as a
					; buffer to read the boot sectors in from the FD & HD.
		push	word ptr [bp-0Eh]
		lea	di, [bp-0Ch]
		push	di
		lea	di, [bp-8]
		push	di

loc_FC61D:
		call	sub_FD140
		add	sp, 6
		mov	di, [bp-0Ch]

loc_FC626:
		add	di, [bp-0Eh]
		mov	BOOT_IOPB.BUF_OFFSET, di

loc_FC62D:				; CODE XREF: BOOT_TYPE_00_CMP86+26j
		mov	BOOT_IOPB.SECTOR_COUNT,	15

loc_FC632:
		jmp	short AFTER_JUMP_TABLE
BOOT_TYPE_01_OASIS endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


BOOT_TYPE_02_UNIX proc near		; CODE XREF: DO_DISK_BOOT+FCj
					; DATA XREF: ROM:0661o
		mov	word ptr [bp-8], offset	BOOT_SECTOR_BUF	; While	overlaying the IO progrem this RAM area	does not
					; seem to be passed to the IOP.	Instead, it is used as a
					; buffer to read the boot sectors in from the FD & HD.
		mov	di, 200h
		push	di
		lea	di, [bp-0Ch]
		push	di
		lea	di, [bp-8]
		push	di
		call	sub_FD140
		add	sp, 6
		mov	di, [bp-0Ch]
		add	di, 200h
		mov	BOOT_IOPB.BUF_OFFSET, di
		mov	BOOT_IOPB.SECTOR_COUNT,	2
		jmp	short AFTER_JUMP_TABLE
BOOT_TYPE_02_UNIX endp

; ───────────────────────────────────────────────────────────────────────────
BOOT_TYPE_HANDLERS dw offset BOOT_TYPE_00_CMP86	; DATA XREF: DO_DISK_BOOT+FCr
					; Handle CP/M boot. Doesn't seem to be actually used.
					; Actualy CP/M images use XENIX	style boot (type 0x02)
		dw offset BOOT_TYPE_01_OASIS ; Handle OASIS boot.
					; Doesn't seem to be actually used.
					; OASIS	is a system that runs on Z80 anyways.
		dw offset BOOT_TYPE_02_UNIX

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


AFTER_JUMP_TABLE proc near		; CODE XREF: BOOT_TYPE_00_CMP86+4Cj
					; BOOT_TYPE_01_OASIS:loc_FC632j ...
		call	RUN_IOP
		cmp	BOOT_IOPB.RETURN_STATUS, 0
		jz	short loc_FC670
		jmp	BOOT_BAD
; ───────────────────────────────────────────────────────────────────────────

loc_FC670:				; CODE XREF: AFTER_JUMP_TABLE+8j
		call	NEWLINE
		call	sub_FCC9E

loc_FC676:
		call	near ptr RESTORE_REGS

loc_FC679:				; CODE XREF: DO_DISK_BOOT+96j
		jmp	COMMON_RETURN
AFTER_JUMP_TABLE endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

BOOT_FAILED	proc near		; CODE XREF: DO_DISK_BOOT:BOOT_BADp
		push	bp
		mov	bp, sp
		push	di
		push	si

loc_FC681:				; "\nBoot Failed, Status="
		mov	di, offset aBootFailedStatus
		push	di
		call	PRINT_STRING
		add	sp, 2
		mov	al, BOOT_IOPB.RETURN_STATUS
		cbw
		push	ax
		call	PRINT_HEX_STAT
		add	sp, 2
		jmp	COMMON_RETURN
BOOT_FAILED	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FC69A	proc near		; CODE XREF: sub_FD055p
		push	bp
		mov	bp, sp
		push	di
		push	si
		mov	di, 1
		push	di
		call	PRINT_STH
		add	sp, 2
		call	READ_CHAR_TO_AL
		mov	COMMAND_CHAR, al
		cmp	COMMAND_CHAR, 0Dh
		jnz	short loc_FC6BC
		call	ERROR_CONSOLE

loc_FC6B9:				; CODE XREF: sub_FC69A+27j
					; sub_FC69A+2Cj
		jmp	COMMON_RETURN
; ───────────────────────────────────────────────────────────────────────────

loc_FC6BC:				; CODE XREF: sub_FC69A+1Aj
		call	sub_FCA34
		test	ax, ax
		jz	short loc_FC6B9
		call	DO_DISK_IOPB
		jmp	short loc_FC6B9
sub_FC69A	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

DO_DISK_IOPB	proc near		; CODE XREF: F08_09_DISK_IOPB+Ap
					; sub_FC69A+29p

SYSCALL_ARG_BYTE_OFFSET= word ptr -6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 2
		mov	[bp+SYSCALL_ARG_BYTE_OFFSET], 0

FETCH_NEXT_BYTE:			; CODE XREF: DO_DISK_IOPB+23j
		push	[bp+SYSCALL_ARG_BYTE_OFFSET] ; Copy syscall argument into BOOT_IOPB
		call	GET_SYSCALL_ARG_BYTE ; BX = offset
		pop	bx
		mov	byte ptr BOOT_IOPB.field_0[bx],	al
		inc	SYSCALL_ARG_OFF
		inc	[bp+SYSCALL_ARG_BYTE_OFFSET]
		cmp	[bp+SYSCALL_ARG_BYTE_OFFSET], IOPB.field_14 ; Monitor reserved
		jb	short FETCH_NEXT_BYTE
		sub	SYSCALL_ARG_OFF, IOPB.field_14 ; Monitor reserved
		call	RUN_IOP
		add	SYSCALL_ARG_OFF, 0Bh
		mov	al, BOOT_IOPB.RETURN_STATUS
		cbw
		push	ax
		call	SYSCALL_ARG_PUT_VALUE ;	Value on stack
		add	sp, 2
		jmp	COMMON_RETURN
DO_DISK_IOPB	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

RUN_IOP		proc near		; CODE XREF: DO_DISK_BOOT+7Ep
					; DO_DISK_BOOT:IS_FLOPPYp ...
		push	bp
		mov	bp, sp
		push	di
		push	si
		mov	di, 1
		call	DO_SUBMIT_IOP	; Translate IOPB into something	that's
					; understood by	the Z80	handling I/O
		jmp	COMMON_RETURN
RUN_IOP		endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Translate IOPB into something	that's
; understood by	the Z80	handling I/O
; Attributes: bp-based frame

DO_SUBMIT_IOP	proc near		; CODE XREF: RUN_IOP+8p

RETRIES		= word ptr -8
RETR_X		= word ptr -6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 4
		mov	di, BOOT_IOPB.BUF_OFFSET
		mov	ax, di
		mov	byte ptr IOP_09_OFF_HI,	al ; FD/HD - Destination offset	HI
		mov	dx, di
		mov	cx, 8
		sar	dx, cl
		mov	byte ptr IOP_0A_OFF_LO,	dl ; FD/HD - Destination offset	LO
		mov	di, BOOT_IOPB.BUF_SEGMENT
		mov	ax, di
		mov	byte ptr IOP_0B_SEF_HI,	al ; FD/HD - Destination segment HI
		mov	dx, di
		mov	cx, 8
		sar	dx, cl
		mov	byte ptr IOP_0C_SEG_LO,	dl ; FD/HD - Destination segment LO
		mov	byte ptr IOP_0D_STATUS,	0 ; FD/HD - Operation status. (FF=not run, 00=success)
		cmp	BOOT_IOPB.DRIVE, 4
		jl	short IS_FLOPPY
		jmp	IS_HARD_DISK
; ───────────────────────────────────────────────────────────────────────────

IS_FLOPPY:				; CODE XREF: DO_SUBMIT_IOP+3Aj
		mov	al, BOOT_IOPB.IOPCODE
		and	ax, 0F0h
		cmp	ax, 10h
		jz	short FDD_HANDLE_CMD_10
		cmp	ax, 20h	; ' '
		jnz	short FDD_CMD_NOT_20
		jmp	FDD_HANDLE_CMD
; ───────────────────────────────────────────────────────────────────────────

FDD_CMD_NOT_20:				; CODE XREF: DO_SUBMIT_IOP+4Dj
		cmp	ax, 30h	; '0'
		jnz	short FDD_CMD_NOT_30
		jmp	FDD_HANDLE_CMD
; ───────────────────────────────────────────────────────────────────────────

FDD_CMD_NOT_30:				; CODE XREF: DO_SUBMIT_IOP+55j
		cmp	ax, 60h	; '`'
		jnz	short FDD_CMD_NOT_SUPP
		jmp	FDD_HANDLE_CMD_60_FORMAT
; ───────────────────────────────────────────────────────────────────────────

FDD_CMD_NOT_SUPP:			; CODE XREF: DO_SUBMIT_IOP+5Dj
		mov	si, offset aFloppyCommandNotSupport ; "\nFloppy	command	not supported."
		push	si
		call	PRINT_STRING
		add	sp, 2
		jmp	GO_RETURN
; ───────────────────────────────────────────────────────────────────────────

FDD_HANDLE_CMD_10:			; CODE XREF: DO_SUBMIT_IOP+48j
		mov	IOP_00_OPCODE, 0Fh ; HD/FD - command
		mov	al, BOOT_IOPB.HEAD
		cbw
		shl	ax, 1
		shl	ax, 1
		mov	byte ptr IOP_01_BUSY, al ; HD/FD - busy	status
		mov	dx, BOOT_IOPB.TRACK
		mov	byte ptr IOP_02, dl ; FDD - read/write track
					; HDD -	read/write track LO
					; FDD -	format sector side (01/02)

FDD_POKE_IOP2:				; CODE XREF: DO_SUBMIT_IOP+145j
					; DO_SUBMIT_IOP+195j
		mov	[bp+RETR_X], 27
		mov	FDD_DOORBELL, 0FFh
		mov	byte ptr IOP_0D_STATUS,	0FFh ; FD/HD - Operation status. (FF=not run, 00=success)
		mov	al, byte ptr IOP_01_BUSY ; HD/FD - busy	status
		cbw
		or	ax, 80h
		mov	byte ptr IOP_01_BUSY, al ; HD/FD - busy	status
		mov	IOP_IRQ_DOORBELL, 0FFh ; IR2/IR7 "Hard/Floppy Disk Interrupt" zero this	out
		mov	si, 7008h	; IOP2 IO Interrupt - FLOPPY
		push	si
		mov	si, offset IOP_00_OPCODE ; HD/FD - command
		push	si
		mov	si, offset IOP1_PTR.PB_SEG
		push	si
		call	IOP_SEND	; Call floppy
		add	sp, 6

FDD_COMMAND_DONE:			; CODE XREF: DO_SUBMIT_IOP+C9j
					; DO_SUBMIT_IOP+D0j
		dec	[bp+RETR_X]
		jnz	short FDD_SET_RETRIES
		jmp	FDD_CMD_WAIT_OVER
; ───────────────────────────────────────────────────────────────────────────

FDD_SET_RETRIES:			; CODE XREF: DO_SUBMIT_IOP+BAj
		mov	[bp+RETRIES], 64000

FDD_POLL_COMMAND_DONE:			; CODE XREF: DO_SUBMIT_IOP+CEj
		cmp	IOP_IRQ_DOORBELL, 0 ; IR2/IR7 "Hard/Floppy Disk	Interrupt" zero	this out
		jz	short FDD_COMMAND_DONE
		dec	[bp+RETRIES]
		jnz	short FDD_POLL_COMMAND_DONE
		jmp	short FDD_COMMAND_DONE
; ───────────────────────────────────────────────────────────────────────────

FDD_HANDLE_CMD:				; CODE XREF: DO_SUBMIT_IOP+4Fj
					; DO_SUBMIT_IOP+57j
		mov	dl, BOOT_IOPB.IOPCODE
		and	dx, 0F0h
		cmp	dx, 20h	; ' '
		jnz	short FDD_CMD_NOT_20X
		mov	IOP_00_OPCODE, 46h ; 'F' ; Floppy READ
		jmp	short FDD_COMMAND
; ───────────────────────────────────────────────────────────────────────────

FDD_CMD_NOT_20X:			; CODE XREF: DO_SUBMIT_IOP+DDj
		mov	IOP_00_OPCODE, 45h ; 'E' ; Floppy ???

FDD_COMMAND:				; CODE XREF: DO_SUBMIT_IOP+E4j
		mov	al, BOOT_IOPB.HEAD
		cbw
		shl	ax, 1
		shl	ax, 1
		mov	byte ptr IOP_01_BUSY, al ; HD/FD - busy	status
		mov	dx, BOOT_IOPB.TRACK
		mov	byte ptr IOP_02, dl ; FDD - read/write track
					; HDD -	read/write track LO
					; FDD -	format sector side (01/02)
		mov	dl, BOOT_IOPB.HEAD
		mov	byte ptr IOP_03, dl ; FDD - read/write head/side
					; HDD -	read/write track HI
					; FDD -	format sectors per track
		mov	dl, BOOT_IOPB.SECTOR
		mov	byte ptr IOP_04_SECTOR,	dl ; FDD - read/write start sector
					; HDD -	read/write sector
					; FDD -	format tracks
		cmp	BOOT_IOPB.SECTOR_LEN, 512
		jnz	short FDD_SECTOR_NOT_512X
		mov	byte ptr IOP_05, 2 ; FDD read/write - Sector size 02 = 512, 01 = 256
					; HDD read/write - Sector count
					; FDD format - Fill byte E5h
		jmp	short FDD_SECTOR_SIZE_SET
; ───────────────────────────────────────────────────────────────────────────

FDD_SECTOR_NOT_512X:			; CODE XREF: DO_SUBMIT_IOP+114j
		cmp	BOOT_IOPB.SECTOR_LEN, 256
		jnz	short FDD_SECTOR_SIZE_SET
		mov	byte ptr IOP_05, 1 ; FDD read/write - Sector size 02 = 512, 01 = 256
					; HDD read/write - Sector count
					; FDD format - Fill byte E5h

FDD_SECTOR_SIZE_SET:			; CODE XREF: DO_SUBMIT_IOP+11Bj
					; DO_SUBMIT_IOP+123j
		mov	al, BOOT_IOPB.SECTOR_COUNT
		cbw
		mov	dx, ax
		mov	al, BOOT_IOPB.SECTOR
		cbw
		add	dx, ax
		dec	dx
		mov	byte ptr IOP_06, dl ; FDD - end	sector
					; HDD -	head | 0x80
		mov	byte ptr IOP_07, 50h ; 'P' ; FDD - read/write always 50
		mov	byte ptr IOP_08_FDD_50,	0FFh ; FDD - read/write	always ff (HDD unused)
		jmp	FDD_POKE_IOP2
; ───────────────────────────────────────────────────────────────────────────

FDD_HANDLE_CMD_60_FORMAT:		; CODE XREF: DO_SUBMIT_IOP+5Fj
		mov	IOP_00_OPCODE, 4Dh ; 'M' ; HD/FD - command
		mov	dx, BOOT_IOPB.TRACK
		mov	byte ptr IOP_07, dl ; FDD - read/write always 50
		mov	al, BOOT_IOPB.HEAD
		cbw
		shl	ax, 1
		shl	ax, 1
		mov	byte ptr IOP_01_BUSY, al ; HD/FD - busy	status
		cmp	BOOT_IOPB.SECTOR_LEN, 512
		jnz	short FDD_SECTOR_NOT_512
		mov	byte ptr IOP_02, 2 ; FDD - read/write track
					; HDD -	read/write track LO
					; FDD -	format sector side (01/02)
		mov	byte ptr IOP_03, 9 ; FDD - read/write head/side
					; HDD -	read/write track HI
					; FDD -	format sectors per track
		mov	byte ptr IOP_04_SECTOR,	80 ; FDD - read/write start sector
					; HDD -	read/write sector
					; FDD -	format tracks
		jmp	short FDD_DO_HANDLE_CMD_60_FORMAT
; ───────────────────────────────────────────────────────────────────────────

FDD_SECTOR_NOT_512:			; CODE XREF: DO_SUBMIT_IOP+166j
		cmp	BOOT_IOPB.SECTOR_LEN, 256
		jnz	short FDD_DO_HANDLE_CMD_60_FORMAT
		mov	byte ptr IOP_02, 1 ; FDD - read/write track
					; HDD -	read/write track LO
					; FDD -	format sector side (01/02)
		mov	byte ptr IOP_03, 16 ; FDD - read/write head/side
					; HDD -	read/write track HI
					; FDD -	format sectors per track
		mov	byte ptr IOP_04_SECTOR,	12 ; FDD - read/write start sector
					; HDD -	read/write sector
					; FDD -	format tracks

FDD_DO_HANDLE_CMD_60_FORMAT:		; CODE XREF: DO_SUBMIT_IOP+177j
					; DO_SUBMIT_IOP+17Fj
		mov	byte ptr IOP_05, 0E5h ;	'Õ' ; FDD read/write - Sector size 02 = 512, 01 = 256
					; HDD read/write - Sector count
					; FDD format - Fill byte E5h
		jmp	FDD_POKE_IOP2
; ───────────────────────────────────────────────────────────────────────────

FDD_CMD_WAIT_OVER:			; CODE XREF: DO_SUBMIT_IOP+BCj
		cmp	[bp+RETR_X], 0
		jnz	short FDD_CMD_DONE
		cmp	[bp+RETRIES], 0
		jnz	short FDD_CMD_DONE
		mov	si, offset aFloppyTimeoutError ; "\nFloppy timeout error"
		push	si

PRINT_AND_RETURN:			; CODE XREF: DO_SUBMIT_IOP+2B0j
		call	PRINT_STRING
		add	sp, 2

FDD_CMD_DONE:				; CODE XREF: DO_SUBMIT_IOP+19Cj
					; DO_SUBMIT_IOP+1A2j
		mov	dl, byte ptr IOP_0D_STATUS ; FD/HD - Operation status. (FF=not run, 00=success)
		mov	BOOT_IOPB.RETURN_STATUS, dl
		jmp	GO_RETURN
; ───────────────────────────────────────────────────────────────────────────

IS_HARD_DISK:				; CODE XREF: DO_SUBMIT_IOP+3Cj
		mov	al, BOOT_IOPB.IOPCODE
		cbw
		cmp	ax, 1
		jz	short HDD_CMD_01_21_READ
		cmp	ax, 2
		jnz	short HDD_CMD_NOT_02
		jmp	HDD_CMD_02
; ───────────────────────────────────────────────────────────────────────────

HDD_CMD_NOT_02:				; CODE XREF: DO_SUBMIT_IOP+1C5j
		cmp	ax, 3
		jnz	short HDD_CMD_NOT_03
		jmp	HDD_CMD_03
; ───────────────────────────────────────────────────────────────────────────

HDD_CMD_NOT_03:				; CODE XREF: DO_SUBMIT_IOP+1CDj
		cmp	ax, 20h	; ' '
		jnz	short HDD_CMD_NOT_20
		jmp	HDD_CMD_20
; ───────────────────────────────────────────────────────────────────────────

HDD_CMD_NOT_20:				; CODE XREF: DO_SUBMIT_IOP+1D5j
		cmp	ax, 21h	; '!'
		jz	short HDD_CMD_01_21_READ
		jmp	HDD_COMMAND_NOT_SUPP
; ───────────────────────────────────────────────────────────────────────────

HDD_CMD_01_21_READ:			; CODE XREF: DO_SUBMIT_IOP+1C0j
					; DO_SUBMIT_IOP+1DDj
		mov	IOP_00_OPCODE, 2Ch ; ',' ; HD/FD - command

HDD_HANDLE_CMD:				; CODE XREF: DO_SUBMIT_IOP+299j
					; DO_SUBMIT_IOP+2A1j ...
		mov	al, BOOT_IOPB.DRIVE
		cbw
		mov	cx, 3
		shl	ax, cl
		mov	dx, ax
		mov	al, INT34_IR2_HDD_PTR
		cbw
		or	dx, ax
		or	dx, 20h
		mov	byte ptr IOP_01_BUSY, dl ; HD/FD - busy	status
		mov	di, BOOT_IOPB.TRACK
		mov	dx, di
		mov	cx, 8
		sar	dx, cl
		mov	byte ptr IOP_02, dl ; FDD - read/write track
					; HDD -	read/write track LO
					; FDD -	format sector side (01/02)
		mov	ax, di
		mov	byte ptr IOP_03, al ; FDD - read/write head/side
					; HDD -	read/write track HI
					; FDD -	format sectors per track
		mov	dl, BOOT_IOPB.SECTOR
		mov	byte ptr IOP_04_SECTOR,	dl ; FDD - read/write start sector
					; HDD -	read/write sector
					; FDD -	format tracks
		mov	dl, BOOT_IOPB.SECTOR_COUNT
		mov	byte ptr IOP_05, dl ; FDD read/write - Sector size 02 =	512, 01	= 256
					; HDD read/write - Sector count
					; FDD format - Fill byte E5h
		mov	al, BOOT_IOPB.HEAD
		cbw
		mov	dx, ax
		mov	al, BOOT_IOPB.DRIVE
		cbw
		mov	cx, 5
		shl	ax, cl
		or	dx, ax
		mov	byte ptr IOP_06, dl ; FDD - end	sector
					; HDD -	head | 0x80

HDD_STATUS_NOT_DONE:			; CODE XREF: DO_SUBMIT_IOP+277j
		mov	[bp+RETRIES], 64000
		mov	byte ptr IOP_0D_STATUS,	0FFh ; FD/HD - Operation status. (FF=not run, 00=success)
		mov	IOP_IRQ_DOORBELL, 0FFh ; IR2/IR7 "Hard/Floppy Disk Interrupt" zero this	out
		mov	si, 7000h	; IO PORT
		push	si
		mov	si, offset IOP_00_OPCODE ; Address of IOP block
		push	si
		mov	si, offset IOP1_PTR ; Pointer to IOPB
		push	si
		call	IOP_SEND
		add	sp, 6

HDD_WAIT_IRQ:				; CODE XREF: DO_SUBMIT_IOP+264j
		cmp	IOP_IRQ_DOORBELL, 0 ; IR2/IR7 "Hard/Floppy Disk	Interrupt" zero	this out
		jz	short HDD_IRQ_ARRIVED
		dec	[bp+RETRIES]
		jnz	short HDD_WAIT_IRQ

HDD_IRQ_ARRIVED:			; CODE XREF: DO_SUBMIT_IOP+25Fj
		mov	dl, BOOT_IOPB.RETRIES
		dec	BOOT_IOPB.RETRIES
		test	dl, dl
		jle	short HDD_IRQ_WAIT_DONE
		cmp	byte ptr IOP_0D_STATUS,	0 ; FD/HD - Operation status. (FF=not run, 00=success)
		jnz	short HDD_STATUS_NOT_DONE

HDD_IRQ_WAIT_DONE:			; CODE XREF: DO_SUBMIT_IOP+270j
		cmp	[bp+RETRIES], 0
		jnz	short HDD_CMD_DONE
		mov	si, offset aHardDiskTimeoutError ; "\nHard disk	timeout	error"
		push	si
		call	PRINT_STRING
		add	sp, 2

HDD_CMD_DONE:				; CODE XREF: DO_SUBMIT_IOP+27Dj
		mov	dl, byte ptr IOP_0D_STATUS ; FD/HD - Operation status. (FF=not run, 00=success)
		mov	BOOT_IOPB.RETURN_STATUS, dl

GO_RETURN:				; CODE XREF: DO_SUBMIT_IOP+6Cj
					; DO_SUBMIT_IOP+1B6j
		jmp	COMMON_RETURN
; ───────────────────────────────────────────────────────────────────────────

HDD_CMD_02:				; CODE XREF: DO_SUBMIT_IOP+1C7j
		mov	IOP_00_OPCODE, 34h ; '4' ; HD/FD - command
		jmp	HDD_HANDLE_CMD
; ───────────────────────────────────────────────────────────────────────────

HDD_CMD_20:				; CODE XREF: DO_SUBMIT_IOP+1D7j
		mov	IOP_00_OPCODE, 10h ; HD/FD - command
		jmp	HDD_HANDLE_CMD
; ───────────────────────────────────────────────────────────────────────────

HDD_CMD_03:				; CODE XREF: DO_SUBMIT_IOP+1CFj
		mov	IOP_00_OPCODE, 50h ; 'P' ; HD/FD - command
		jmp	HDD_HANDLE_CMD
; ───────────────────────────────────────────────────────────────────────────

HDD_COMMAND_NOT_SUPP:			; CODE XREF: DO_SUBMIT_IOP+1DFj
		mov	si, offset aHardDiskCommandNotSuppo ; "\nHard disk command not supported."
		push	si
		jmp	PRINT_AND_RETURN
DO_SUBMIT_IOP	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Prints and asterisk on console and beeps
; Attributes: bp-based frame

ERROR_CONSOLE	proc near		; CODE XREF: sub_FC69A+1Cp
					; sub_FCAA2:loc_FCB56p	...

var_8		= word ptr -8
var_6		= byte ptr -6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 4
		mov	byte ptr [bp+var_8], '*'
		mov	byte ptr [bp+var_8+1], 7 ; Beep
		mov	[bp+var_6], ' '
		lea	di, [bp+var_8]
		push	di
		mov	di, 3		; STRLEN('*\b ')
		push	di
		sub	di, di
		push	di
		call	PUTS_CONSOLE
		add	sp, 6
		jmp	COMMON_RETURN
ERROR_CONSOLE	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

DO_FLOPPY_CMD	proc near		; CODE XREF: DO_FLOPPY_BOOT+4p
					; BOOT_TYPE_01_OASIS+14p

DRIVE_NUMBER	= byte ptr  4
SEC_IS_256	= byte ptr  6

		push	bp
		mov	bp, sp
		push	di
		push	si
		cmp	[bp+SEC_IS_256], 1
		jnz	short SEC_512
		mov	di, 256
		jmp	short SEC_DONE
; ───────────────────────────────────────────────────────────────────────────

SEC_512:				; CODE XREF: DO_FLOPPY_CMD+9j
		mov	di, 512

SEC_DONE:				; CODE XREF: DO_FLOPPY_CMD+Ej
		mov	al, [bp+DRIVE_NUMBER]
		cbw
		mov	cx, 5
		shl	ax, cl
		mov	si, ax
		mov	FDC_REGS.SECTOR_SIZE[si], di
		mov	FDC_REGS.FLOPPY_DATA_BUF_PTR, offset FLOPPY_BUF
		mov	FDC_REGS.FLOPPY_COMMAND_REG, 87h ; 'ç'
		inc	NEW_CMD_REG

POLL_FLOPPY_COMMAND_DONE:		; CODE XREF: DO_FLOPPY_CMD+3Dj
		mov	dl, FDC_REGS.FLOPPY_COMMAND_REG
		and	dx, 80h
		cmp	dx, 80h	; 'Ç'
		jz	short POLL_FLOPPY_COMMAND_DONE
		jmp	COMMON_RETURN
DO_FLOPPY_CMD	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FCA34	proc near		; CODE XREF: sub_FC69A:loc_FC6BCp
					; sub_FCC14:loc_FCC36p	...

var_6		= byte ptr -6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 2
		mov	[bp+var_6], 1
		mov	SYSCALL_ARG_SEG, 0
		mov	di, 0F53h
		push	di
		call	sub_FCAA2
		add	sp, 2
		test	ax, ax
		jz	short loc_FCA77
		cmp	COMMAND_CHAR, 3Ah ; ':'
		jnz	short loc_FCA7B
		mov	di, SYSCALL_ARG_OFF
		mov	SYSCALL_ARG_SEG, di
		call	READ_CHAR_TO_AL
		mov	COMMAND_CHAR, al
		mov	di, 0F53h
		push	di
		call	sub_FCAA2
		add	sp, 2
		test	ax, ax
		jnz	short loc_FCA7B

loc_FCA77:				; CODE XREF: sub_FCA34+1Ej
		mov	[bp+var_6], 0

loc_FCA7B:				; CODE XREF: sub_FCA34+25j
					; sub_FCA34+41j
		mov	al, [bp+var_6]
		cbw
		jmp	COMMON_RETURN
sub_FCA34	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

READ_CHAR_TO_AL	proc near		; CODE XREF: sub_FC69A+Fp
					; sub_FCA34+2Fp ...

var_6		= word ptr -6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 2
		call	sub_FD9A6
		mov	byte ptr [bp+var_6], al
		lea	di, [bp+var_6]
		push	di
		call	PUTCHAR_CONSOLE
		add	sp, 2
		mov	al, byte ptr [bp+var_6]
		cbw
		jmp	COMMON_RETURN
READ_CHAR_TO_AL	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FCAA2	proc near		; CODE XREF: sub_FCA34+16p
					; sub_FCA34+39p ...

var_A		= word ptr -0Ah
var_8		= byte ptr -8
var_6		= word ptr -6
arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 6
		mov	[bp+var_8], 2Bh	; '+'
		mov	[bp+var_A], 0
		mov	di, [bp+arg_0]
		mov	word ptr [di], 0
		jmp	short loc_FCAE4
; ───────────────────────────────────────────────────────────────────────────

loc_FCABC:				; CODE XREF: sub_FCAA2+53j
		mov	di, [bp+var_A]
		mov	cx, 4
		shl	di, cl
		mov	al, byte ptr [bp+var_6]
		cbw
		add	di, ax
		mov	[bp+var_A], di
		call	sub_FD9A6
		mov	COMMAND_CHAR, al
		cmp	COMMAND_CHAR, 0Dh
		jz	short loc_FCAF7
		mov	di, offset COMMAND_CHAR
		push	di
		call	PUTCHAR_CONSOLE
		add	sp, 2

loc_FCAE4:				; CODE XREF: sub_FCAA2+18j
					; sub_FCAA2+B1j
		lea	di, [bp+var_6]
		push	di
		mov	al, COMMAND_CHAR
		cbw
		push	ax
		call	sub_FD944
		add	sp, 4
		test	ax, ax
		jnz	short loc_FCABC

loc_FCAF7:				; CODE XREF: sub_FCAA2+36j
		cmp	[bp+var_8], 2Bh	; '+'
		jnz	short loc_FCB07
		mov	bx, [bp+arg_0]
		mov	di, [bp+var_A]
		add	[bx], di
		jmp	short loc_FCB0F
; ───────────────────────────────────────────────────────────────────────────

loc_FCB07:				; CODE XREF: sub_FCAA2+59j
		mov	bx, [bp+arg_0]
		mov	di, [bp+var_A]
		sub	[bx], di

loc_FCB0F:				; CODE XREF: sub_FCAA2+63j
		cmp	COMMAND_CHAR, 0Dh
		jz	short loc_FCB2B
		cmp	COMMAND_CHAR, 3Ah ; ':'
		jz	short loc_FCB2B
		cmp	COMMAND_CHAR, 2Ch ; ','
		jz	short loc_FCB2B
		cmp	COMMAND_CHAR, 20h ; ' '
		jnz	short loc_FCB33

loc_FCB2B:				; CODE XREF: sub_FCAA2+72j
					; sub_FCAA2+79j ...
		mov	di, 1

loc_FCB2E:				; CODE XREF: sub_FCAA2+B9j
		mov	ax, di
		jmp	COMMON_RETURN
; ───────────────────────────────────────────────────────────────────────────

loc_FCB33:				; CODE XREF: sub_FCAA2+87j
		cmp	COMMAND_CHAR, 2Bh ; '+'
		jz	short loc_FCB41
		cmp	COMMAND_CHAR, 2Dh ; '-'
		jnz	short loc_FCB56

loc_FCB41:				; CODE XREF: sub_FCAA2+96j
		mov	dl, COMMAND_CHAR
		mov	[bp+var_8], dl
		mov	[bp+var_A], 0
		call	READ_CHAR_TO_AL
		mov	COMMAND_CHAR, al
		jmp	loc_FCAE4
; ───────────────────────────────────────────────────────────────────────────

loc_FCB56:				; CODE XREF: sub_FCAA2+9Dj
		call	ERROR_CONSOLE
		sub	di, di
		jmp	short loc_FCB2E
sub_FCAA2	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FCB5E	proc near		; CODE XREF: sub_FD85A+85p
					; sub_FDC92+Ep

var_6		= word ptr -6
arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 2
		mov	bx, [bp+arg_0]
		mov	byte ptr [bx], 0
		jmp	short loc_FCB9A
; ───────────────────────────────────────────────────────────────────────────

loc_FCB6E:				; CODE XREF: sub_FCB5E+4Dj
		mov	bx, [bp+arg_0]
		mov	al, [bx]
		cbw
		mov	cx, 4
		shl	ax, cl
		mov	dx, ax
		mov	al, byte ptr [bp+var_6]
		cbw
		add	dx, ax
		mov	[bx], dl
		call	sub_FD9A6
		mov	COMMAND_CHAR, al
		cmp	COMMAND_CHAR, 0Dh
		jz	short loc_FCBAD
		mov	di, offset COMMAND_CHAR
		push	di
		call	PUTCHAR_CONSOLE
		add	sp, 2

loc_FCB9A:				; CODE XREF: sub_FCB5E+Ej
		lea	di, [bp+var_6]
		push	di
		mov	al, COMMAND_CHAR
		cbw
		push	ax
		call	sub_FD944
		add	sp, 4
		test	ax, ax
		jnz	short loc_FCB6E

loc_FCBAD:				; CODE XREF: sub_FCB5E+30j
		cmp	COMMAND_CHAR, 0Dh
		jz	short loc_FCBCC
		cmp	COMMAND_CHAR, 20h ; ' '
		jz	short loc_FCBCC
		cmp	COMMAND_CHAR, 2Ch ; ','
		jz	short loc_FCBCC
		call	ERROR_CONSOLE
		sub	di, di

loc_FCBC7:				; CODE XREF: sub_FCB5E+71j
		mov	ax, di
		jmp	COMMON_RETURN
; ───────────────────────────────────────────────────────────────────────────

loc_FCBCC:				; CODE XREF: sub_FCB5E+54j
					; sub_FCB5E+5Bj ...
		mov	di, 1
		jmp	short loc_FCBC7
sub_FCB5E	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


RESTORE_REGS	proc far		; CODE XREF: AFTER_JUMP_TABLE:loc_FC676p
					; sub_FCC14+1Fp ...
		mov	ax, offset sub_FC2B1
		mov	bx, 4
		mov	[bx], ax
		mov	word ptr [bx+2], cs
		mov	bx, 0Ch
		mov	[bx], ax
		mov	word ptr [bx+2], cs
		mov	bx, offset REGISTERS
		mov	di, [bx+CPU_REGS.SAVE_DI]
		mov	si, [bx+CPU_REGS.SAVE_SI]
		mov	dx, [bx+CPU_REGS.SAVE_DX]
		mov	cx, [bx+CPU_REGS.SAVE_CX]
		mov	ax, [bx+CPU_REGS.SAVE_AX]
		mov	es, [bx+CPU_REGS.SAVE_ES]
		mov	ss, [bx+CPU_REGS.SAVE_SS]
		mov	sp, [bx+CPU_REGS.SAVE_SP]
		mov	bp, [bx+CPU_REGS.SAVE_BP]
		push	[bx+CPU_REGS.SAVE_FLAGS]
		push	[bx+CPU_REGS.SAVE_CS]
		push	[bx+CPU_REGS.SAVE_IP]
		push	[bx+CPU_REGS.SAVE_DS]
		mov	bx, [bx+CPU_REGS.SAVE_BX]
		pop	ds
		iret
RESTORE_REGS	endp ; sp = -6


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FCC14	proc near		; CODE XREF: sub_FD047p
		push	bp
		mov	bp, sp
		push	di
		push	si
		mov	di, 1
		push	di
		call	PRINT_STH
		add	sp, 2
		call	READ_CHAR_TO_AL
		mov	COMMAND_CHAR, al
		cmp	COMMAND_CHAR, 0Dh
		jnz	short loc_FCC36
		call	sub_FCC9E
		call	near ptr RESTORE_REGS

loc_FCC36:				; CODE XREF: sub_FCC14+1Aj
		call	sub_FCA34
		test	ax, ax
		jz	short loc_FCC53
		mov	di, SYSCALL_ARG_SEG
		mov	REGISTERS.SAVE_CS, di
		mov	di, SYSCALL_ARG_OFF
		mov	REGISTERS.SAVE_IP, di
		call	sub_FCC9E
		call	near ptr RESTORE_REGS

loc_FCC53:				; CODE XREF: sub_FCC14+27j
		jmp	COMMON_RETURN
sub_FCC14	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FCC56	proc near		; CODE XREF: sub_FD06Ep
		push	bp
		mov	bp, sp
		push	di
		push	si
		mov	di, 1
		push	di
		call	PRINT_STH
		add	sp, 2
		call	READ_CHAR_TO_AL
		mov	COMMAND_CHAR, al
		cmp	COMMAND_CHAR, 0Dh
		jnz	short loc_FCC7B
		or	REGISTERS.SAVE_FLAGS, 100h
		call	near ptr RESTORE_REGS

loc_FCC7B:				; CODE XREF: sub_FCC56+1Aj
		call	sub_FCA34
		test	ax, ax
		jz	short loc_FCC9B
		mov	di, SYSCALL_ARG_SEG
		mov	REGISTERS.SAVE_CS, di
		mov	di, SYSCALL_ARG_OFF
		mov	REGISTERS.SAVE_IP, di
		or	REGISTERS.SAVE_FLAGS, 100h
		call	near ptr RESTORE_REGS

loc_FCC9B:				; CODE XREF: sub_FCC56+2Aj
		jmp	COMMON_RETURN
sub_FCC56	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FCC9E	proc near		; CODE XREF: AFTER_JUMP_TABLE+10p
					; sub_FCC14+1Cp ...

var_6		= word ptr -6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 2
		mov	[bp+var_6], 0

loc_FCCAB:				; CODE XREF: sub_FCC9E+5Dj
		mov	ax, [bp+var_6]
		mov	cx, 6
		imul	cx
		mov	bx, ax
		mov	al, [bx+630h]
		test	al, al
		jz	short loc_FCCF4
		mov	ax, [bp+var_6]
		mov	cx, 6
		imul	cx
		mov	bx, ax
		mov	ax, [bx+632h]
		mov	SYSCALL_ARG_SEG, ax
		mov	ax, [bp+var_6]
		imul	cx
		mov	bx, ax
		mov	ax, [bx+634h]
		mov	SYSCALL_ARG_OFF, ax
		mov	ax, [bp+var_6]
		imul	cx
		push	ax
		call	GET_SYSCALL_ARG_BYTE ; BX = offset
		pop	bx
		mov	[bx+631h], al
		mov	di, 0CCh ; '╠'
		push	di
		call	SYSCALL_ARG_PUT_VALUE ;	Value on stack
		add	sp, 2

loc_FCCF4:				; CODE XREF: sub_FCC9E+1Dj
		inc	[bp+var_6]
		cmp	[bp+var_6], 8
		jb	short loc_FCCAB
		jmp	COMMON_RETURN
sub_FCC9E	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

BREAKPOINT	proc near		; CODE XREF: sub_FC2B1+5Bp

var_6		= word ptr -6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 2
		mov	di, offset aBreak_____0	; "\nBreak ...."
		push	di
		call	PRINT_STRING
		add	sp, 2
		mov	[bp+var_6], 0

loc_FCD17:				; CODE XREF: BREAKPOINT+62j
		mov	ax, [bp+var_6]
		mov	cx, 6
		imul	cx
		mov	bx, ax
		mov	al, [bx+630h]
		test	al, al
		jz	short loc_FCD5B
		mov	ax, [bp+var_6]
		mov	cx, 6
		imul	cx
		mov	bx, ax
		mov	ax, [bx+632h]
		mov	SYSCALL_ARG_SEG, ax
		mov	ax, [bp+var_6]
		imul	cx
		mov	bx, ax
		mov	ax, [bx+634h]
		mov	SYSCALL_ARG_OFF, ax
		mov	ax, [bp+var_6]
		imul	cx
		mov	di, ax
		mov	al, [di+631h]
		cbw
		push	ax
		call	SYSCALL_ARG_PUT_VALUE ;	Value on stack
		add	sp, 2

loc_FCD5B:				; CODE XREF: BREAKPOINT+27j
		inc	[bp+var_6]
		cmp	[bp+var_6], 8
		jb	short loc_FCD17
		or	REGISTERS.SAVE_FLAGS, 100h
		call	near ptr RESTORE_REGS
		jmp	COMMON_RETURN
BREAKPOINT	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

CHANNEL_IO	proc near		; CODE XREF: F14_RESERVED:loc_FC200p
					; sub_FD073p

var_18		= byte ptr -18h
var_16		= word ptr -16h
var_14		= word ptr -14h
var_12		= byte ptr -12h
var_10		= byte ptr -10h
var_E		= word ptr -0Eh
var_C		= word ptr -0Ch
var_A		= word ptr -0Ah

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 14h
		mov	byte ptr [bp+var_A], 3Ah ; ':'
		mov	byte ptr [bp+var_C], 45h ; 'E'
		mov	byte ptr [bp+var_E], 42h ; 'B'
		mov	[bp+var_10], 1
		mov	[bp+var_12], 0
		mov	byte ptr [bp+var_14], 6
		mov	[bp+var_18], 0
		sub	di, di
		jmp	short loc_FCDB3
; ───────────────────────────────────────────────────────────────────────────

loc_FCD98:				; CODE XREF: CHANNEL_IO+47j
		mov	di, offset aChannelNo_04_0 ; "\nChannel	no.(0-4): "
		push	di
		call	PRINT_STRING
		add	sp, 2
		call	READ_CHAR_TO_AL
		mov	[bp+var_16], ax
		lea	di, [bp+var_14]
		push	di
		push	ax
		call	sub_FD944
		add	sp, 4

loc_FCDB3:				; CODE XREF: CHANNEL_IO+26j
		cmp	byte ptr [bp+var_14], 4
		jg	short loc_FCD98
		mov	SYSCALL_ARG_SEG, 0
		mov	SYSCALL_ARG_OFF, 0
		mov	dl, byte ptr [bp+var_14]
		mov	byte_512, dl
		mov	al, byte_512
		cbw
		push	ax
		call	CHANNEL_INIT_RX
		add	sp, 2
		mov	al, byte_512
		cbw
		push	ax
		call	sub_FCF06
		add	sp, 2
		mov	di, offset aReady_0 ; "	Ready- "
		push	di
		call	PRINT_STRING
		add	sp, 2
		mov	word_F26, 0Fh
		mov	di, offset BOOT_SECTOR_BUF ; While overlaying the IO progrem this RAM area does	not
					; seem to be passed to the IOP.	Instead, it is used as a
					; buffer to read the boot sectors in from the FD & HD.
		push	di
		push	word_F26
		mov	al, byte_512
		cbw
		push	ax
		call	CHANNEL_RX
		add	sp, 6
		mov	word_F22, 0
		mov	word_F24, 0
		jmp	loc_FCEE2
; ───────────────────────────────────────────────────────────────────────────

loc_FCE14:				; CODE XREF: CHANNEL_IO+B3j
		inc	word_F24

loc_FCE18:				; CODE XREF: CHANNEL_IO+178j
		call	sub_FDC06
		mov	di, ax
		mov	al, byte ptr [bp+var_A]
		cbw
		cmp	di, ax
		jnz	short loc_FCE14
		cmp	byte_512, 0
		jz	short loc_FCE36
		lea	di, [bp+var_A]
		push	di
		call	PUTCHAR_CONSOLE
		add	sp, 2

loc_FCE36:				; CODE XREF: CHANNEL_IO+BAj
		mov	word_F28, 0
		call	sub_FDBAC
		mov	[bp+var_12], al
		call	sub_FDBE8
		mov	SYSCALL_ARG_OFF, ax
		call	sub_FDBAC
		mov	[bp+var_18], al
		cmp	[bp+var_18], 0
		jge	short loc_FCE58
		mov	[bp+var_18], 0

loc_FCE58:				; CODE XREF: CHANNEL_IO+E2j
		mov	al, [bp+var_12]
		cbw
		mov	di, ax
		mov	al, [bp+var_12]
		cbw
		add	di, ax
		add	di, 0Bh
		add	word_F24, di
		mov	al, [bp+var_18]
		cbw
		cmp	ax, 3
		ja	short loc_FCEB9
		shl	ax, 1
		xchg	ax, bx
		jmp	cs:off_FCEC5[bx]

loc_FCE7C:				; DATA XREF: CHANNEL_IO:off_FCEC5o
		mov	[bp+var_16], 1

loc_FCE81:				; CODE XREF: CHANNEL_IO+12Bj
		mov	al, [bp+var_12]
		cbw
		cmp	ax, [bp+var_16]
		jl	short loc_FCECD
		call	sub_FDBAC
		push	ax
		call	SYSCALL_ARG_PUT_VALUE ;	Value on stack
		add	sp, 2
		inc	SYSCALL_ARG_OFF
		inc	[bp+var_16]
		jmp	short loc_FCE81
; ───────────────────────────────────────────────────────────────────────────

loc_FCE9D:				; CODE XREF: CHANNEL_IO+107j
					; DATA XREF: CHANNEL_IO+157o
		mov	[bp+var_10], 0
		jmp	short loc_FCECD
; ───────────────────────────────────────────────────────────────────────────

loc_FCEA3:				; CODE XREF: CHANNEL_IO+107j
					; DATA XREF: CHANNEL_IO+159o
		call	sub_FDBE8
		mov	SYSCALL_ARG_SEG, ax
		jmp	short loc_FCECD
; ───────────────────────────────────────────────────────────────────────────

loc_FCEAB:				; CODE XREF: CHANNEL_IO+107j
					; DATA XREF: CHANNEL_IO+15Bo
		call	sub_FDBE8
		mov	REGISTERS.SAVE_CS, ax
		call	sub_FDBE8
		mov	REGISTERS.SAVE_IP, ax
		jmp	short loc_FCECD
; ───────────────────────────────────────────────────────────────────────────

loc_FCEB9:				; CODE XREF: CHANNEL_IO+102j
		lea	di, [bp+var_E]
		push	di
		call	PUTCHAR_CONSOLE
		add	sp, 2
		jmp	short loc_FCECD
; ───────────────────────────────────────────────────────────────────────────
off_FCEC5	dw offset loc_FCE7C	; DATA XREF: CHANNEL_IO+107r
		dw offset loc_FCE9D
		dw offset loc_FCEA3
		dw offset loc_FCEAB
; ───────────────────────────────────────────────────────────────────────────

loc_FCECD:				; CODE XREF: CHANNEL_IO+118j
					; CHANNEL_IO+131j ...
		call	sub_FDBAC
		test	word_F28, 0FFh
		jz	short loc_FCEE2
		lea	di, [bp+var_C]
		push	di
		call	PUTCHAR_CONSOLE
		add	sp, 2

loc_FCEE2:				; CODE XREF: CHANNEL_IO+A1j
					; CHANNEL_IO+166j
		cmp	[bp+var_10], 0
		jz	short loc_FCEEB
		jmp	loc_FCE18
; ───────────────────────────────────────────────────────────────────────────

loc_FCEEB:				; CODE XREF: CHANNEL_IO+176j
		mov	di, offset aDone_0 ; " -Done"
		push	di
		call	PRINT_STRING
		add	sp, 2
		mov	al, byte_512
		cbw
		push	ax
		call	CHANNEL_INIT
		add	sp, 2
		call	DUMP_REGS
		jmp	COMMON_RETURN
CHANNEL_IO	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FCF06	proc near		; CODE XREF: CHANNEL_IO+6Cp

arg_0		= byte ptr  4

		push	bp
		mov	bp, sp
		push	di
		push	si
		jmp	short loc_FCF18
; ───────────────────────────────────────────────────────────────────────────

loc_FCF0D:				; CODE XREF: sub_FCF06+28j
		mov	al, [bp+arg_0]
		cbw
		push	ax
		call	DO_GETCHAR
		add	sp, 2

loc_FCF18:				; CODE XREF: sub_FCF06+5j
		mov	al, COMMAND_CHAR
		cbw
		push	ax
		mov	di, 0FFFFh
		push	di
		mov	al, [bp+arg_0]
		cbw
		push	ax
		call	CHANNEL_RX

loc_FCF29:
		add	sp, 6
		test	ax, ax
		jnz	short loc_FCF0D
		jmp	COMMON_RETURN
sub_FCF06	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

DO_AUTO_BOOT	proc near		; CODE XREF: F00_AUTO_BOOT+1Dp
					; sub_FC2B1+55p

var_8		= byte ptr -8
var_6		= word ptr -6
arg_0		= word ptr  4

		push	bp

loc_FCF35:
		mov	bp, sp
		push	di
		push	si
		sub	sp, 4
		cmp	[bp+arg_0], 0
		jnz	short loc_FCF45
		jmp	PROMPT_AND_DISPATCH
; ───────────────────────────────────────────────────────────────────────────

loc_FCF45:				; CODE XREF: DO_AUTO_BOOT+Cj
		mov	di, offset aMonitorVersionA2_2 ; "\nMonitor Version a2.2"
		push	di
		call	PRINT_STRING
		add	sp, 2
		cmp	POST_STATUS_01,	0
		jz	short loc_FCF59
		jmp	loc_FCFD0
; ───────────────────────────────────────────────────────────────────────────

loc_FCF59:				; CODE XREF: DO_AUTO_BOOT+20j
		mov	di, offset aPressAnyKeyToInterruptB ; "\nPress any key to interrupt boot\n"
		push	di
		call	PRINT_STRING
		add	sp, 2
		mov	[bp+var_6], 1

loc_FCF68:				; CODE XREF: DO_AUTO_BOOT+94j
		cmp	[bp+var_6], 50h	; 'P'
		ja	short loc_FCFA3

loc_FCF6E:
		mov	di, 64h	; 'd'
		push	di
		call	DELAY		; Time on stack
		add	sp, 2
		mov	al, COMMAND_CHAR
		cbw
		push	ax
		mov	di, 0FFFFh
		push	di
		sub	di, di
		push	di
		call	CHANNEL_RX
		add	sp, 6
		test	ax, ax
		jnz	short loc_FCF92
		sub	di, di
		jmp	short loc_FCF95
; ───────────────────────────────────────────────────────────────────────────

loc_FCF92:				; CODE XREF: DO_AUTO_BOOT+58j
		mov	di, 1

loc_FCF95:				; CODE XREF: DO_AUTO_BOOT+5Cj
		mov	dx, di
		mov	[bp+var_8], dl
		test	dl, dl
		jz	short loc_FCFC5
		mov	[bp+var_6], 51h	; 'Q'

loc_FCFA3:				; CODE XREF: DO_AUTO_BOOT+38j
		cmp	[bp+var_8], 0
		jnz	short loc_FCFCA
		mov	di, offset aBootingFromHardDisk	; "\nBooting from Hard Disk"
		push	di
		call	PRINT_STRING
		add	sp, 2

BOOT_CHOICE_HDD:			; CODE XREF: DO_AUTO_BOOT+C2j
		call	IOP8089_CMD
		mov	di, 4		; 4 = Hard disk	0
		push	di
		call	DO_DISK_BOOT
		add	sp, 2

loc_FCFC0:				; CODE XREF: DO_AUTO_BOOT+D1j
					; POST_NOT_FAILED+5j
		call	ERROR_CONSOLE
		jmp	short loc_FCFD0
; ───────────────────────────────────────────────────────────────────────────

loc_FCFC5:				; CODE XREF: DO_AUTO_BOOT+68j
		inc	[bp+var_6]
		jmp	short loc_FCF68
; ───────────────────────────────────────────────────────────────────────────

loc_FCFCA:				; CODE XREF: DO_AUTO_BOOT+73j
		call	sub_FD9A6
		mov	COMMAND_CHAR, al

loc_FCFD0:				; CODE XREF: DO_AUTO_BOOT+22j
					; DO_AUTO_BOOT+8Fj ...
		mov	di, offset BOOT_PROMPT ; Enter [1] to boot from	Hard Disk
					; Enter	[2] to boot from Floppy	Disk
					; Enter	[3] to enter Monitor
		push	di
		call	PRINT_STRING
		add	sp, 2
		call	READ_CHAR_TO_AL
		mov	COMMAND_CHAR, al
		cmp	POST_STATUS_01,	0
		jz	short loc_FCFEA
		call	CHANNEL_0_INIT

loc_FCFEA:				; CODE XREF: DO_AUTO_BOOT+B1j
		mov	al, COMMAND_CHAR
		cbw
		cmp	ax, 27		; ESC
		jz	short sub_FD024
		cmp	ax, '1'
		jz	short BOOT_CHOICE_HDD
		cmp	ax, '2'
		jz	short BOOT_CHOICE_FDD
		cmp	ax, '3'
		jz	short BOOT_CHOICE_MONITOR
		cmp	ax, '?'
		jnz	short loc_FCFC0
		jmp	short PROMPT_AND_DISPATCH
; ───────────────────────────────────────────────────────────────────────────

BOOT_CHOICE_FDD:			; CODE XREF: DO_AUTO_BOOT+C7j
		call	IOP8089_CMD
		sub	di, di		; 0 = Floppy disk 0
		push	di
		call	DO_DISK_BOOT

loc_FD012:				; CODE XREF: sub_FD04C+7j
		add	sp, 2
		jmp	short PROMPT_AND_DISPATCH
DO_AUTO_BOOT	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


DISPATCH_SOME_FUNC proc	near		; CODE XREF: PROMPT_AND_DISPATCH+1Cj
		shl	ax, 1
		xchg	ax, bx
		jmp	cs:SOME_FUNC_VECTOR[bx]
DISPATCH_SOME_FUNC endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


BOOT_CHOICE_MONITOR proc near		; CODE XREF: DO_AUTO_BOOT+CCj
		call	IOP8089_CMD
		jmp	short PROMPT_AND_DISPATCH
BOOT_CHOICE_MONITOR endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


sub_FD024	proc near		; CODE XREF: DO_AUTO_BOOT+BDj
		cmp	POST_STATUS_02,	0
		jz	short POST_NOT_FAILED
		call	POST_FAILED
		jmp	short loc_FCFD0
sub_FD024	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


POST_NOT_FAILED	proc near		; CODE XREF: sub_FD024+5j
		mov	COMMAND_CHAR, 20h ; ' '
		jmp	loc_FCFC0
POST_NOT_FAILED	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


sub_FD038	proc near		; CODE XREF: DISPATCH_SOME_FUNC+3j
					; DATA XREF: ROM:SOME_FUNC_VECTORo
		call	sub_FD85A
		jmp	short PROMPT_AND_DISPATCH
sub_FD038	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


sub_FD03D	proc near		; CODE XREF: DISPATCH_SOME_FUNC+3j
					; DATA XREF: ROM:109Co
		call	sub_FD554
		jmp	short PROMPT_AND_DISPATCH
sub_FD03D	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


sub_FD042	proc near		; CODE XREF: DISPATCH_SOME_FUNC+3j
					; DATA XREF: ROM:10A0o
		call	sub_FD9DE
		jmp	short PROMPT_AND_DISPATCH
sub_FD042	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


sub_FD047	proc near		; CODE XREF: DISPATCH_SOME_FUNC+3j
					; DATA XREF: ROM:10A6o
		call	sub_FCC14
		jmp	short PROMPT_AND_DISPATCH
sub_FD047	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


sub_FD04C	proc near		; CODE XREF: DISPATCH_SOME_FUNC+3j
					; DATA XREF: ROM:10AAo
		mov	di, 1
		push	di

loc_FD050:				; CODE XREF: sub_FD064+3j
		call	HANDLE_IO_COMMAND
		jmp	short loc_FD012
sub_FD04C	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


sub_FD055	proc near		; CODE XREF: DISPATCH_SOME_FUNC+3j
					; DATA XREF: ROM:10AEo
		call	sub_FC69A
		jmp	short PROMPT_AND_DISPATCH
sub_FD055	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


sub_FD05A	proc near		; CODE XREF: DISPATCH_SOME_FUNC+3j
					; DATA XREF: ROM:10B0o
		call	sub_FD906
		jmp	short PROMPT_AND_DISPATCH
sub_FD05A	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


sub_FD05F	proc near		; CODE XREF: DISPATCH_SOME_FUNC+3j
					; DATA XREF: ROM:10B2o
		call	sub_FD0CE
		jmp	short PROMPT_AND_DISPATCH
sub_FD05F	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


sub_FD064	proc near		; CODE XREF: DISPATCH_SOME_FUNC+3j
					; DATA XREF: ROM:10B6o
		sub	di, di
		push	di
		jmp	short loc_FD050
sub_FD064	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


DUMP_REGISTERS	proc near		; CODE XREF: DISPATCH_SOME_FUNC+3j
					; DATA XREF: ROM:10BCo
		call	DO_DUMP_REGISTERS
		jmp	short PROMPT_AND_DISPATCH
DUMP_REGISTERS	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


sub_FD06E	proc near		; CODE XREF: DISPATCH_SOME_FUNC+3j
					; DATA XREF: ROM:10BEo
		call	sub_FCC56
		jmp	short PROMPT_AND_DISPATCH
sub_FD06E	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


sub_FD073	proc near		; CODE XREF: DISPATCH_SOME_FUNC+3j
					; DATA XREF: ROM:10C8o
		call	CHANNEL_IO
sub_FD073	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


PROMPT_AND_DISPATCH proc near		; CODE XREF: DO_AUTO_BOOT+Ej
					; DO_AUTO_BOOT+D3j ...
		mov	di, offset PROMPT_STR ;	"\n< A,	B, D, G, I, K, L, M, O,	R, S, X	>"...
		push	di
		call	PRINT_STRING
		add	sp, 2
		call	READ_CHAR_TO_AL
		mov	COMMAND_CHAR, al
		mov	al, COMMAND_CHAR
		cbw
		sub	ax, 'A'
		cmp	ax, 17h
		ja	short NEXT_ONE
		jmp	DISPATCH_SOME_FUNC
PROMPT_AND_DISPATCH endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


NEXT_ONE	proc near		; CODE XREF: DISPATCH_SOME_FUNC+3j
					; PROMPT_AND_DISPATCH+1Aj
					; DATA XREF: ...
		call	ERROR_CONSOLE
		jmp	short PROMPT_AND_DISPATCH
NEXT_ONE	endp

; ───────────────────────────────────────────────────────────────────────────
SOME_FUNC_VECTOR dw offset sub_FD038	; DATA XREF: DISPATCH_SOME_FUNC+3r
		dw offset sub_FD03D
		dw offset NEXT_ONE
		dw offset sub_FD042
		dw offset NEXT_ONE
		dw offset NEXT_ONE
		dw offset sub_FD047
		dw offset NEXT_ONE
		dw offset sub_FD04C
		dw offset NEXT_ONE
		dw offset sub_FD055
		dw offset sub_FD05A
		dw offset sub_FD05F
		dw offset NEXT_ONE
		dw offset sub_FD064
		dw offset NEXT_ONE
		dw offset NEXT_ONE
		dw offset DUMP_REGISTERS
		dw offset sub_FD06E
		dw offset NEXT_ONE
		dw offset NEXT_ONE
		dw offset NEXT_ONE
		dw offset NEXT_ONE
		dw offset sub_FD073
; ───────────────────────────────────────────────────────────────────────────
		jmp	PROMPT_AND_DISPATCH
; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FD0CE	proc near		; CODE XREF: sub_FD05Fp

var_E		= word ptr -0Eh
var_C		= word ptr -0Ch
var_A		= word ptr -0Ah
var_8		= word ptr -8
var_6		= word ptr -6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 0Ah
		mov	di, 1
		push	di
		call	PRINT_STH
		add	sp, 2
		call	sub_FDC68
		test	ax, ax
		jz	short loc_FD13C
		cmp	COMMAND_CHAR, 0Dh
		jnz	short loc_FD0F3

loc_FD0EE:				; CODE XREF: sub_FD0CE+3Fj
		call	ERROR_CONSOLE
		jmp	short loc_FD13C
; ───────────────────────────────────────────────────────────────────────────

loc_FD0F3:				; CODE XREF: sub_FD0CE+1Ej
		mov	di, SYSCALL_ARG_OFF
		mov	[bp+var_8], di
		mov	di, SYSCALL_ARG_SEG
		mov	[bp+var_6], di
		call	sub_FDC68
		test	ax, ax
		jz	short loc_FD13C
		cmp	COMMAND_CHAR, 0Dh
		jz	short loc_FD0EE
		mov	di, SYSCALL_ARG_OFF
		mov	[bp+var_C], di
		mov	di, SYSCALL_ARG_SEG
		mov	[bp+var_A], di
		lea	di, [bp+var_E]
		push	di
		call	SET_VALUE
		add	sp, 2
		test	ax, ax
		jz	short loc_FD13C
		push	[bp+var_E]
		lea	di, [bp+var_C]
		push	di
		lea	di, [bp+var_8]
		push	di
		call	sub_FD140
		add	sp, 6

loc_FD13C:				; CODE XREF: sub_FD0CE+17j
					; sub_FD0CE+23j ...
		jmp	COMMON_RETURN
sub_FD0CE	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FD140	proc near		; CODE XREF: BOOT_TYPE_00_CMP86+11p
					; BOOT_TYPE_01_OASIS:loc_FC61Dp ...

arg_0		= word ptr  4
arg_2		= word ptr  6
arg_4		= word ptr  8

		push	bp
		mov	bp, sp
		push	ds
		push	di
		push	si
		push	es
		mov	di, [bp+arg_2]
		mov	es, word ptr [di+2]
		mov	di, [di]
		mov	bx, [bp+arg_0]
		mov	si, [bx]
		mov	ds, word ptr [bx+2]
		mov	cx, [bp+arg_4]
		cld
		rep movsb
		pop	es
		pop	si
		pop	di
		pop	ds
		pop	bp
		retn
sub_FD140	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

HANDLE_IO_COMMAND proc near		; CODE XREF: sub_FD04C:loc_FD050p

IO_VALUE	= word ptr -0Ah
IOPORT_ADDR	= word ptr -8
WANT_WORD_IO	= byte ptr -6
arg_0		= byte ptr  4

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 6
		mov	[bp+WANT_WORD_IO], 1
		mov	di, 1
		push	di
		call	PRINT_STH
		add	sp, 2
		call	READ_CHAR_TO_AL
		mov	COMMAND_CHAR, al
		cmp	COMMAND_CHAR, 'B' ; 'B' Command - Byte
		jnz	short NOT_B
		mov	[bp+WANT_WORD_IO], 0

W_COMMAND:				; CODE XREF: HANDLE_IO_COMMAND+6Cj
		mov	di, 1
		push	di
		call	PRINT_STH
		add	sp, 2
		lea	di, [bp+IOPORT_ADDR]
		push	di
		call	SET_VALUE
		add	sp, 2
		test	ax, ax
		jz	short loc_FD1D5
		mov	di, 1
		push	di
		call	PRINT_STH
		add	sp, 2
		cmp	[bp+arg_0], 0
		jz	short loc_FD1E7
		cmp	[bp+WANT_WORD_IO], 0
		jz	short DO_BYTE_IN
		push	[bp+IOPORT_ADDR]
		call	DO_INW
		add	sp, 2
		push	ax
		call	sub_FD2E6

loc_FD1C6:				; CODE XREF: HANDLE_IO_COMMAND+81j
		add	sp, 2
		jmp	short loc_FD1D5
; ───────────────────────────────────────────────────────────────────────────

NOT_B:					; CODE XREF: HANDLE_IO_COMMAND+21j
		cmp	COMMAND_CHAR, 'W' ; 'W' Command - Word
		jz	short W_COMMAND
		call	ERROR_CONSOLE

loc_FD1D5:				; CODE XREF: HANDLE_IO_COMMAND+3Dj
					; HANDLE_IO_COMMAND+65j ...
		jmp	COMMON_RETURN
; ───────────────────────────────────────────────────────────────────────────

DO_BYTE_IN:				; CODE XREF: HANDLE_IO_COMMAND+53j
		push	[bp+IOPORT_ADDR]
		call	DO_INB
		add	sp, 2
		push	ax
		call	PRINT_HEX_STAT
		jmp	short loc_FD1C6
; ───────────────────────────────────────────────────────────────────────────

loc_FD1E7:				; CODE XREF: HANDLE_IO_COMMAND+4Dj
		lea	di, [bp+IO_VALUE]
		push	di
		call	SET_VALUE
		add	sp, 2
		test	ax, ax
		jz	short loc_FD1D5
		cmp	[bp+WANT_WORD_IO], 0
		jz	short DO_BYTE_OUT
		push	[bp+IO_VALUE]
		push	[bp+IOPORT_ADDR]
		call	DO_OUTW

loc_FD204:				; CODE XREF: HANDLE_IO_COMMAND+AEj
		add	sp, 4
		jmp	short loc_FD1D5
; ───────────────────────────────────────────────────────────────────────────

DO_BYTE_OUT:				; CODE XREF: HANDLE_IO_COMMAND+95j
		push	[bp+IO_VALUE]
		push	[bp+IOPORT_ADDR]
		call	DO_OUTB
		jmp	short loc_FD204
HANDLE_IO_COMMAND endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

PRINT_STRING	proc near		; CODE XREF: POST_FINISH+E0p
					; POST_FAILED+23p ...

arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		push	di
		push	si
		push	[bp+arg_0]
		sub	di, di
		push	di
		push	di
		call	DO_PUTS
		add	sp, 6
		jmp	COMMON_RETURN
PRINT_STRING	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

DO_PUTS		proc near		; CODE XREF: F07_IO_PUTS+6p
					; PRINT_STRING+Cp

var_8		= byte ptr -8
STR_LEN_ZERO	= word ptr -6
IO_CHAN		= word ptr  4
STR_SEG		= word ptr  6
STR_OFF		= word ptr  8

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 4
		mov	[bp+STR_LEN_ZERO], 0
		mov	di, [bp+STR_SEG]
		mov	SYSCALL_ARG_SEG, di
		mov	di, [bp+STR_OFF]
		mov	SYSCALL_ARG_OFF, di
		jmp	short loc_FD28D
; ───────────────────────────────────────────────────────────────────────────

loc_FD247:				; CODE XREF: DO_PUTS+54j DO_PUTS+5Aj
		push	[bp+STR_OFF]
		push	[bp+STR_SEG]
		push	[bp+STR_LEN_ZERO]
		push	[bp+IO_CHAN]
		call	CHANNEL_TX
		add	sp, 8
		cmp	[bp+var_8], 0Ah
		jnz	short loc_FD26C
		push	[bp+IO_CHAN]
		call	DO_IO_NEWLINE
		add	sp, 2
		inc	SYSCALL_ARG_OFF

loc_FD26C:				; CODE XREF: DO_PUTS+33j
		mov	di, SYSCALL_ARG_OFF
		mov	[bp+STR_OFF], di
		mov	[bp+STR_LEN_ZERO], 0
		jmp	short loc_FD28D
; ───────────────────────────────────────────────────────────────────────────

loc_FD27A:				; CODE XREF: DO_PUTS+6Bj
		cmp	[bp+var_8], 0Ah
		jz	short loc_FD247
		cmp	[bp+STR_LEN_ZERO], 0Ah
		jge	short loc_FD247
		inc	[bp+STR_LEN_ZERO]
		inc	SYSCALL_ARG_OFF

loc_FD28D:				; CODE XREF: DO_PUTS+1Bj DO_PUTS+4Ej
		call	GET_SYSCALL_ARG_BYTE ; BX = offset
		mov	[bp+var_8], al
		test	al, al
		jnz	short loc_FD27A
		push	[bp+STR_OFF]
		push	[bp+STR_SEG]
		push	[bp+STR_LEN_ZERO]
		push	[bp+IO_CHAN]
		call	CHANNEL_TX
		add	sp, 8
		jmp	COMMON_RETURN
DO_PUTS		endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

NEWLINE		proc near		; CODE XREF: POST_FINISH+B5p
					; AFTER_JUMP_TABLE:loc_FC670p ...
		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	di, di
		push	di
		call	DO_IO_NEWLINE
		add	sp, 2
		jmp	COMMON_RETURN
NEWLINE		endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

DO_IO_NEWLINE	proc near		; CODE XREF: F06_IO_NEWLINE+1p
					; DO_PUTS+38p ...

var_6		= word ptr -6
IO_CHAN		= word ptr  4

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 2
		mov	byte ptr [bp+var_6], 0Dh
		mov	byte ptr [bp+var_6+1], 0Ah
		lea	di, [bp+var_6]
		push	di
		sub	di, di
		push	di
		mov	di, 2
		push	di
		push	[bp+IO_CHAN]
		call	CHANNEL_TX
		add	sp, 8
		jmp	COMMON_RETURN
DO_IO_NEWLINE	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FD2E6	proc near		; CODE XREF: HANDLE_IO_COMMAND+5Fp
					; DO_DUMP_REGISTERS+48p ...

arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		push	di
		push	si
		mov	di, [bp+arg_0]
		and	di, 0FF00h
		mov	cx, 8
		sar	di, cl
		push	di
		call	PRINT_HEX_STAT
		add	sp, 2
		mov	di, [bp+arg_0]
		and	di, 0FFh
		push	di
		call	PRINT_HEX_STAT
		add	sp, 2
		jmp	COMMON_RETURN
sub_FD2E6	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

PRINT_HEX_STAT	proc near		; CODE XREF: BOOT_FAILED+14p
					; HANDLE_IO_COMMAND+7Ep ...

var_8		= word ptr -8
var_6		= word ptr -6
arg_0		= byte ptr  4

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 4
		lea	di, [bp+var_8]
		push	di
		lea	di, [bp+var_6]
		push	di
		mov	al, [bp+arg_0]
		cbw
		push	ax
		call	FORMAT_HEX_NUMBER
		add	sp, 6
		lea	di, [bp+var_6]
		push	di
		call	PUTCHAR_CONSOLE
		add	sp, 2
		lea	di, [bp+var_8]
		push	di
		call	PUTCHAR_CONSOLE
		add	sp, 2
		jmp	COMMON_RETURN
PRINT_HEX_STAT	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FD342	proc near		; CODE XREF: sub_FD554+43p
					; sub_FD554:loc_FD612p	...
		push	bp
		mov	bp, sp
		push	di
		push	si
		call	NEWLINE
		mov	di, 2
		push	di
		call	PRINT_STH
		add	sp, 2
		jmp	COMMON_RETURN
sub_FD342	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

PRINT_STH	proc near		; CODE XREF: sub_FC69A+9p sub_FCC14+9p ...

var_8		= word ptr -8
var_6		= word ptr -6
arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 4
		mov	byte ptr [bp+var_6], 20h ; ' '
		mov	[bp+var_8], 1
		jmp	short loc_FD378
; ───────────────────────────────────────────────────────────────────────────

loc_FD36B:				; CODE XREF: PRINT_STH+26j
		lea	di, [bp+var_6]
		push	di
		call	PUTCHAR_CONSOLE
		add	sp, 2
		inc	[bp+var_8]

loc_FD378:				; CODE XREF: PRINT_STH+11j
		mov	di, [bp+arg_0]
		cmp	[bp+var_8], di
		jle	short loc_FD36B
		jmp	COMMON_RETURN
PRINT_STH	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

CHANNEL_RX	proc near		; CODE XREF: F01_05_IO_CHANNEL_STATUS+7p
					; DO_GETCHAR+15p ...

IO_CHAN		= byte ptr  4
arg_2		= word ptr  6
arg_4		= word ptr  8

		push	bp
		mov	bp, sp
		push	si
		push	di
		mov	bx, [bp+arg_4]
		mov	al, 16h		; sizeof(CHAN_REGS)
		mul	[bp+IO_CHAN]
		lea	si, IO_REGS
		add	si, ax
		cmp	[bp+arg_2], 0FFFFh
		jz	short loc_FD40E
		xor	cx, cx
		cmp	cx, [bp+arg_2]
		jnb	short loc_FD405
		mov	dx, [si+CHAN_REGS.CHAN_RX_LEN] ; Receive Data Buffer Length Register
		mov	ax, [si+CHAN_REGS.CHAN_RX_OUT] ; Receive Buffer	Output Pointer Register
		mov	di, word ptr [si+CHAN_REGS.CHAN_RX_LO] ; Receive Data Buffer Address Register LO
		add	di, ax

loc_FD3B0:				; CODE XREF: CHANNEL_RX+34j
					; CHANNEL_RX+39j ...
		call	WAIT_FOR_COMMAND_DONE ;	Wait until 0x80	(command valid)	bit falls off
		mov	ax, [si+CHAN_REGS.CHAN_RX_IN] ;	Receive	Buffer Input Pointer Register
		test	ax, ax
		js	short loc_FD3B0
		cmp	ax, [si+CHAN_REGS.CHAN_RX_OUT] ; Receive Buffer	Output Pointer Register
		jz	short loc_FD3B0
		mov	ax, [si+CHAN_REGS.CHAN_STAT] ; Channel Status Register
		and	ax, 0F0h
		jz	short loc_FD3D2
		mov	[si+CHAN_REGS.CHAN_CMD], 89h ; 'ë' ; Command 9 = Reset Error Condition
		call	INC_NEW_CMD_REG
		mov	al, 0
		jmp	short loc_FD421
; ───────────────────────────────────────────────────────────────────────────

loc_FD3D2:				; CODE XREF: CHANNEL_RX+41j
					; CHANNEL_RX+76j
		mov	al, [di]
		and	al, 7Fh
		inc	[si+CHAN_REGS.CHAN_RX_OUT] ; Receive Buffer Output Pointer Register
		inc	di
		cmp	[si+CHAN_REGS.CHAN_RX_OUT], dx ; Receive Buffer	Output Pointer Register
		jb	short loc_FD3E7
		mov	[si+CHAN_REGS.CHAN_RX_OUT], 0 ;	Receive	Buffer Output Pointer Register
		mov	di, word ptr [si+CHAN_REGS.CHAN_RX_LO] ; Receive Data Buffer Address Register LO

loc_FD3E7:				; CODE XREF: CHANNEL_RX+59j
		mov	[bx], al
		inc	bx
		inc	cx
		cmp	cx, [bp+arg_2]
		jnb	short loc_FD405

loc_FD3F0:				; CODE XREF: CHANNEL_RX+71j
		mov	ax, [si+CHAN_REGS.CHAN_RX_IN] ;	Receive	Buffer Input Pointer Register
		test	ax, ax
		js	short loc_FD3F0
		cmp	ax, [si+CHAN_REGS.CHAN_RX_OUT] ; Receive Buffer	Output Pointer Register
		jnz	short loc_FD3D2
		mov	[si+CHAN_REGS.CHAN_CMD], 83h ; 'â' ; Command 3 = Acknowledge receiver
		call	INC_NEW_CMD_REG
		jmp	short loc_FD3B0
; ───────────────────────────────────────────────────────────────────────────

loc_FD405:				; CODE XREF: CHANNEL_RX+1Fj
					; CHANNEL_RX+6Aj
		mov	[si+CHAN_REGS.CHAN_CMD], 83h ; 'â' ; Command 3 = Acknowledge receiver
		call	INC_NEW_CMD_REG
		jmp	short loc_FD421
; ───────────────────────────────────────────────────────────────────────────

loc_FD40E:				; CODE XREF: CHANNEL_RX+18j
		mov	dx, [si+CHAN_REGS.CHAN_PARM] ; Channel Parameter Register
		mov	al, 0FFh

loc_FD413:				; CODE XREF: CHANNEL_RX+94j
		mov	bx, [si+CHAN_REGS.CHAN_RX_IN] ;	Receive	Buffer Input Pointer Register
		test	bx, bx
		js	short loc_FD413
		cmp	bx, [si+CHAN_REGS.CHAN_RX_OUT] ; Receive Buffer	Output Pointer Register
		jnz	short loc_FD421
		xor	al, al

loc_FD421:				; CODE XREF: CHANNEL_RX+4Cj
					; CHANNEL_RX+88j ...
		pop	di
		pop	si
		pop	bp
		retn
CHANNEL_RX	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

CHANNEL_TX	proc near		; CODE XREF: F04_IO_SETATTR+6p
					; DO_PUTS+29p ...

IO_CHAN		= byte ptr  4
STR_LEN_OR_ZERO_OF_FFFF= word ptr  6
STR_OFF		= word ptr  8
STR_SEG		= word ptr  0Ah

		push	bp		; I/O channel number
		mov	bp, sp
		push	si
		push	di
		mov	al, 16h		; sizeof(CHAN_REGS)
		mul	[bp+IO_CHAN]
		lea	si, IO_REGS
		add	si, ax
		cmp	[bp+STR_LEN_OR_ZERO_OF_FFFF], 0FFFFh
		jz	short WRITE_ATTRS
		cmp	[bp+STR_LEN_OR_ZERO_OF_FFFF], 0
		jle	short ZERO_TERMINATED
		call	WAIT_FOR_COMMAND_DONE ;	Wait until 0x80	(command valid)	bit falls off

WAIT_FOR_CHAN_STATUS:			; CODE XREF: CHANNEL_TX+2Cj
		mov	cx, [si+CHAN_REGS.CHAN_STAT] ; Channel Status Register
		and	cx, 1000h
		cmp	cx, 1000h
		jnz	short WAIT_FOR_CHAN_STATUS
		mov	al, 0Ah
		mul	[bp+IO_CHAN]
		mov	cl, 8
		lea	di, STR_BUFS
		add	di, ax
		mov	dx, di
		and	dx, 0FFh
		mov	[si+CHAN_REGS.CHAN_TX_LO], dl ;	Transmit Data Buffer Address Register LO
		mov	dx, di
		and	dx, 0FF00h
		shr	dx, cl
		mov	word ptr [si+CHAN_REGS.CHAN_TX_MID], dx	; Transmit Data	Buffer Address Register	MID
		mov	cx, [bp+STR_LEN_OR_ZERO_OF_FFFF]
		cmp	cx, 0Ah
		jbe	short MAX_0A_CHARS
		mov	cx, 0Ah

MAX_0A_CHARS:				; CODE XREF: CHANNEL_TX+56j
		mov	[si+CHAN_REGS.CHAN_TX_LEN], cx ; Transmit Data Buffer Length Register
		push	si
		mov	ds, [bp+STR_OFF]
		mov	si, [bp+STR_SEG]
		rep movsb
		pop	si
		mov	ax, 0
		mov	ds, ax
		mov	[si+CHAN_REGS.CHAN_CMD], 82h ; 'é' ; Channel Command Register
		call	INC_NEW_CMD_REG
		jmp	short ZERO_TERMINATED
; ───────────────────────────────────────────────────────────────────────────

WRITE_ATTRS:				; CODE XREF: CHANNEL_TX+15j
		mov	ax, [bp+STR_OFF]
		mov	[si+CHAN_REGS.CHAN_PARM], ax ; Channel Parameter Register
		mov	al, 81h	; 'ü'
		call	SUMBIT_CHAN_CMD	; SI = channel register	block
					; AL = command

ZERO_TERMINATED:			; CODE XREF: CHANNEL_TX+1Cj
					; CHANNEL_TX+74j
		pop	di
		pop	si
		pop	bp
		retn
CHANNEL_TX	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

DO_DUMP_REGISTERS proc near		; CODE XREF: DUMP_REGISTERSp

var_C		= byte ptr -0Ch
var_A		= byte ptr -0Ah
var_8		= word ptr -8
var_6		= word ptr -6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 8
		mov	byte ptr [bp+var_6], 2Dh ; '-'
		mov	di, 1
		push	di
		call	PRINT_STH
		add	sp, 2
		call	READ_CHAR_TO_AL
		mov	[bp+var_A], al
		cmp	[bp+var_A], 0Dh
		jnz	short loc_FD529
		call	DUMP_REGS
		jmp	short DO_RETURN
; ───────────────────────────────────────────────────────────────────────────

loc_FD4D1:				; CODE XREF: DO_DUMP_REGISTERS+98j
		mov	bx, [bp+var_8]
		shl	bx, 1
		mov	dl, byte ptr (REG_NAMES+1)[bx]
		cmp	dl, [bp+var_C]
		jnz	short loc_FD545
		mov	di, 2
		push	di
		call	PRINT_STH
		add	sp, 2
		mov	di, [bp+var_8]
		shl	di, 1
		push	word ptr REGISTERS.SAVE_AX[di]
		call	sub_FD2E6
		add	sp, 2
		lea	di, [bp+var_6]
		push	di
		call	PUTCHAR_CONSOLE
		add	sp, 2
		call	READ_CHAR_TO_AL
		mov	COMMAND_CHAR, al
		cmp	COMMAND_CHAR, 20h ; ' '
		jz	short DO_RETURN
		cmp	COMMAND_CHAR, 0Dh
		jz	short DO_RETURN
		mov	di, [bp+var_8]
		shl	di, 1
		add	di, 0F35h
		push	di
		call	sub_FCAA2
		add	sp, 2

DO_RETURN:				; CODE XREF: DO_DUMP_REGISTERS+25j
					; DO_DUMP_REGISTERS+63j ...
		jmp	COMMON_RETURN
; ───────────────────────────────────────────────────────────────────────────

loc_FD529:				; CODE XREF: DO_DUMP_REGISTERS+20j
		call	READ_CHAR_TO_AL
		mov	[bp+var_C], al
		mov	[bp+var_8], 0

loc_FD534:				; CODE XREF: DO_DUMP_REGISTERS+A2j
		mov	bx, [bp+var_8]
		shl	bx, 1
		mov	dl, [bx+660h]
		cmp	dl, [bp+var_A]
		jnz	short loc_FD545
		jmp	loc_FD4D1
; ───────────────────────────────────────────────────────────────────────────

loc_FD545:				; CODE XREF: DO_DUMP_REGISTERS+33j
					; DO_DUMP_REGISTERS+96j
		inc	[bp+var_8]
		cmp	[bp+var_8], 0Bh
		jbe	short loc_FD534
		call	ERROR_CONSOLE
		jmp	short DO_RETURN
DO_DUMP_REGISTERS endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FD554	proc near		; CODE XREF: sub_FD03Dp

var_A		= word ptr -0Ah
var_8		= word ptr -8
var_6		= word ptr -6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 6
		mov	byte ptr [bp+var_6], 3Ah ; ':'
		mov	di, 1
		push	di
		call	PRINT_STH
		add	sp, 2
		call	READ_CHAR_TO_AL
		mov	COMMAND_CHAR, al
		cmp	COMMAND_CHAR, 0Dh
		jnz	short loc_FD5E4
		mov	[bp+var_A], 0

loc_FD57C:				; CODE XREF: sub_FD554+8Ej
		cmp	[bp+var_A], 8
		jb	short loc_FD585
		jmp	loc_FD60F
; ───────────────────────────────────────────────────────────────────────────

loc_FD585:				; CODE XREF: sub_FD554+2Cj
		mov	ax, [bp+var_A]
		mov	cx, 6
		imul	cx
		mov	bx, ax
		mov	al, byte_630[bx]
		test	al, al
		jz	short loc_FD5DF
		call	sub_FD342
		push	[bp+var_A]
		call	PRINT_HEX_STAT
		add	sp, 2
		mov	di, 2
		push	di
		call	PRINT_STH
		add	sp, 2
		mov	ax, [bp+var_A]
		mov	cx, 6
		imul	cx
		mov	bx, ax
		push	word_632[bx]
		call	sub_FD2E6
		add	sp, 2
		lea	di, [bp+var_6]
		push	di
		call	PUTCHAR_CONSOLE
		add	sp, 2
		mov	ax, [bp+var_A]
		mov	cx, 6
		imul	cx
		mov	bx, ax
		push	word_634[bx]
		call	sub_FD2E6
		add	sp, 2

loc_FD5DF:				; CODE XREF: sub_FD554+41j
		inc	[bp+var_A]
		jmp	short loc_FD57C
; ───────────────────────────────────────────────────────────────────────────

loc_FD5E4:				; CODE XREF: sub_FD554+21j
		cmp	COMMAND_CHAR, 2Dh ; '-'
		jnz	short loc_FD61A
		lea	di, [bp+var_8]
		push	di
		call	sub_FDC92
		add	sp, 2
		test	ax, ax
		jz	short loc_FD612
		cmp	byte ptr [bp+var_8], 8
		jge	short loc_FD612
		mov	al, byte ptr [bp+var_8]
		cbw
		mov	cx, 6
		imul	cx
		mov	di, ax
		mov	byte_630[di], 0

loc_FD60F:				; CODE XREF: sub_FD554+2Ej
					; sub_FD554+C4j ...
		jmp	COMMON_RETURN
; ───────────────────────────────────────────────────────────────────────────

loc_FD612:				; CODE XREF: sub_FD554+A3j
					; sub_FD554+A9j
		call	sub_FD342

loc_FD615:				; CODE XREF: sub_FD554+E2j
					; sub_FD554+E9j ...
		call	ERROR_CONSOLE
		jmp	short loc_FD60F
; ───────────────────────────────────────────────────────────────────────────

loc_FD61A:				; CODE XREF: sub_FD554+95j
		mov	[bp+var_A], 0

loc_FD61F:				; CODE XREF: sub_FD554+121j
		mov	ax, [bp+var_A]
		mov	cx, 6
		imul	cx
		mov	bx, ax
		mov	al, [bx+630h]
		test	al, al
		jnz	short loc_FD66E
		call	sub_FCA34
		test	ax, ax
		jz	short loc_FD615
		cmp	COMMAND_CHAR, 0Dh
		jnz	short loc_FD615
		mov	di, SYSCALL_ARG_SEG
		mov	ax, [bp+var_A]
		mov	cx, 6
		imul	cx
		mov	si, ax
		mov	[si+632h], di
		mov	di, SYSCALL_ARG_OFF
		mov	ax, [bp+var_A]
		imul	cx
		mov	si, ax
		mov	[si+634h], di
		mov	ax, [bp+var_A]
		imul	cx
		mov	di, ax
		mov	byte ptr [di+630h], 1
		jmp	short loc_FD60F
; ───────────────────────────────────────────────────────────────────────────

loc_FD66E:				; CODE XREF: sub_FD554+DBj
		inc	[bp+var_A]
		cmp	[bp+var_A], 8
		jb	short loc_FD61F
		jmp	short loc_FD615
sub_FD554	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

DUMP_REGS	proc near		; CODE XREF: sub_FC2B1+4Fp
					; CHANNEL_IO+190p ...

var_8		= word ptr -8
var_6		= word ptr -6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 4
		mov	byte ptr [bp+var_6], 3Ah ; ':'
		mov	di, offset aCsIp_0 ; "\nCS:IP "
		push	di
		call	PRINT_STRING
		add	sp, 2
		push	REGISTERS.SAVE_CS
		call	sub_FD2E6
		add	sp, 2
		lea	di, [bp+var_6]
		push	di
		call	PUTCHAR_CONSOLE
		add	sp, 2
		push	REGISTERS.SAVE_IP
		call	sub_FD2E6
		add	sp, 2
		mov	di, offset aFlags_0 ; "	 Flags	"
		push	di
		call	PRINT_STRING
		add	sp, 2
		call	sub_FD71A
		call	sub_FD342
		mov	[bp+var_8], 0

loc_FD6C3:				; CODE XREF: DUMP_REGS+71j
		mov	di, [bp+var_8]
		shl	di, 1
		add	di, offset REG_NAMES ; "AX"
		push	di
		mov	di, 2
		push	di
		sub	di, di
		push	di
		call	PUTS_CONSOLE
		add	sp, 6
		mov	di, 5
		push	di
		call	PRINT_STH
		add	sp, 2
		inc	[bp+var_8]
		cmp	[bp+var_8], 0Bh
		jb	short loc_FD6C3
		call	sub_FD342
		mov	[bp+var_8], 0

loc_FD6F5:				; CODE XREF: DUMP_REGS+9Bj
		mov	di, [bp+var_8]
		shl	di, 1
		push	word ptr [di+0F35h]
		call	sub_FD2E6
		add	sp, 2
		mov	di, 3
		push	di
		call	PRINT_STH
		add	sp, 2
		inc	[bp+var_8]
		cmp	[bp+var_8], 0Bh
		jb	short loc_FD6F5
		jmp	COMMON_RETURN
DUMP_REGS	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FD71A	proc near		; CODE XREF: DUMP_REGS+3Ep

var_1C		= word ptr -1Ch
var_1A		= byte ptr -1Ah
var_19		= byte ptr -19h
var_18		= byte ptr -18h
var_17		= byte ptr -17h
var_16		= byte ptr -16h
var_15		= byte ptr -15h
var_14		= byte ptr -14h
var_13		= byte ptr -13h
var_12		= byte ptr -12h
var_11		= byte ptr -11h
var_10		= byte ptr -10h
var_F		= byte ptr -0Fh
var_E		= byte ptr -0Eh
var_D		= byte ptr -0Dh
var_A		= word ptr -0Ah
var_8		= word ptr -8
var_6		= word ptr -6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 18h
		mov	byte ptr [bp+var_6], 2Dh ; '-'
		mov	dx, 20h	; ' '
		mov	[bp+var_E], dl
		mov	[bp+var_10], dl
		mov	[bp+var_12], dl
		mov	[bp+var_19], dl
		mov	[bp+var_1A], dl
		mov	byte ptr [bp+var_1C+1],	dl
		mov	byte ptr [bp+var_1C], dl
		mov	[bp+var_18], 4Fh ; 'O'
		mov	[bp+var_17], 44h ; 'D'
		mov	[bp+var_16], 49h ; 'I'
		mov	[bp+var_15], 54h ; 'T'
		mov	[bp+var_14], 53h ; 'S'
		mov	[bp+var_13], 5Ah ; 'Z'
		mov	[bp+var_11], 41h ; 'A'
		mov	[bp+var_F], 50h	; 'P'
		mov	[bp+var_D], 43h	; 'C'
		mov	di, REGISTERS.SAVE_FLAGS
		mov	[bp+var_8], di
		mov	[bp+var_A], 0

loc_FD76E:				; CODE XREF: sub_FD71A+92j
		lea	bx, [bp+var_1C]
		add	bx, [bp+var_A]
		cmp	byte ptr [bx], 20h ; ' '
		jz	short loc_FD79D
		cmp	[bp+var_8], 8000h
		jb	short loc_FD789
		lea	di, [bp+var_1C]
		add	di, [bp+var_A]
		push	di
		jmp	short loc_FD78D
; ───────────────────────────────────────────────────────────────────────────

loc_FD789:				; CODE XREF: sub_FD71A+64j
		lea	di, [bp+var_6]
		push	di

loc_FD78D:				; CODE XREF: sub_FD71A+6Dj
		call	PUTCHAR_CONSOLE
		add	sp, 2
		mov	di, 1
		push	di
		call	PRINT_STH
		add	sp, 2

loc_FD79D:				; CODE XREF: sub_FD71A+5Dj
		mov	di, [bp+var_8]
		shl	di, 1
		mov	[bp+var_8], di
		inc	[bp+var_A]
		cmp	[bp+var_A], 10h
		jb	short loc_FD76E
		jmp	COMMON_RETURN
sub_FD71A	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; SI = channel register	block
; AL = command

SUMBIT_CHAN_CMD	proc near		; CODE XREF: POST_FINISH:NEXT_CHANNELp
					; CHANNEL_0_INIT+14p ...
		call	WAIT_FOR_COMMAND_DONE ;	Wait until 0x80	(command valid)	bit falls off
		mov	[si+CHAN_REGS.CHAN_CMD], al ; 41c + 4
		call	INC_NEW_CMD_REG
		retn
SUMBIT_CHAN_CMD	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; AL = command

SUBMIT_SYS_CMD	proc near		; CODE XREF: POST_FINISH+83p
		push	dx

WAIT_SYS_CMD_FINISH:			; CODE XREF: SUBMIT_SYS_CMD+8j
		mov	dh, byte ptr FW_REG+1
		and	dh, 80h
		jnz	short WAIT_SYS_CMD_FINISH
		mov	byte ptr FW_REG+1, al
		call	INC_NEW_CMD_REG
		pop	dx
		retn
SUBMIT_SYS_CMD	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Value	on stack
; Attributes: bp-based frame

SYSCALL_ARG_PUT_VALUE proc near		; CODE XREF: DO_DISK_IOPB+37p
					; sub_FCC9E+50p ...

VALUE		= byte ptr  4

		push	bp
		mov	bp, sp
		push	ds
		mov	bx, SYSCALL_ARG_OFF
		mov	ds, SYSCALL_ARG_SEG
		mov	al, [bp+VALUE]
		mov	[bx], al
		pop	ds
		pop	bp
		retn
SYSCALL_ARG_PUT_VALUE endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; BX = offset

GET_SYSCALL_ARG_BYTE proc near		; CODE XREF: DO_DISK_IOPB+10p
					; sub_FCC9E+44p ...
		push	ds
		mov	bx, SYSCALL_ARG_OFF
		mov	ds, SYSCALL_ARG_SEG
		mov	al, [bx]
		pop	ds
		retn
GET_SYSCALL_ARG_BYTE endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Wait until 0x80 (command valid) bit falls off

WAIT_FOR_COMMAND_DONE proc near		; CODE XREF: CHANNEL_RX:loc_FD3B0p
					; CHANNEL_TX+1Ep ...
		push	dx

DO_POLL:				; CODE XREF: WAIT_FOR_COMMAND_DONE+7j
		mov	dh, [si+4]
		and	dh, 80h
		jnz	short DO_POLL
		pop	dx
		retn
WAIT_FOR_COMMAND_DONE endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

PUTS_CONSOLE	proc near		; CODE XREF: DO_PUTCHAR+11p
					; ERROR_CONSOLE+1Fp ...

ZERO		= word ptr  4
STR_LEN		= word ptr  6
STR		= word ptr  8

		push	bp
		mov	bp, sp
		push	di
		push	si
		push	[bp+STR]
		sub	di, di
		push	di
		push	[bp+STR_LEN]
		push	[bp+ZERO]
		call	CHANNEL_TX
		add	sp, 8
		jmp	COMMON_RETURN
PUTS_CONSOLE	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

CHANNEL_INIT	proc near		; CODE XREF: CHANNEL_IO+18Ap

IO_CHAN		= byte ptr  4

		push	bp
		mov	bp, sp
		push	si
		mov	al, 16h		; sizeof(CHAN_REGS)
		mul	[bp+IO_CHAN]
		lea	si, IO_REGS
		add	si, ax
		mov	ax, CHAN_REGS.CHAN_RX_LO ; Receive Data	Buffer Address Register	LO
		mov	[si+CHAN_REGS.CHAN_RX_LEN], ax ; Receive Data Buffer Length Register
		mov	ax, 0
		mov	[si+CHAN_REGS.CHAN_RX_IN], ax ;	Receive	Buffer Input Pointer Register
		mov	[si+CHAN_REGS.CHAN_RX_OUT], ax ; Receive Buffer	Output Pointer Register
		mov	al, 81h	; 'ü'   ; Command 1 = Initialize Channel
		call	SUMBIT_CHAN_CMD	; SI = channel register	block
					; AL = command
		pop	si
		pop	bp
		retn
CHANNEL_INIT	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

CHANNEL_INIT_RX	proc near		; CODE XREF: CHANNEL_IO+61p

IO_CHAN		= byte ptr  4

		push	bp
		mov	bp, sp
		push	si
		mov	al, 16h		; sizeof(CHAN_REGS)
		mul	[bp+IO_CHAN]
		lea	si, IO_REGS
		add	si, ax
		mov	ax, 546h
		mov	[si+CHAN_REGS.CHAN_RX_LEN], ax ; Receive Data Buffer Length Register
		mov	al, 81h	; 'ü'   ; Command 1 = Initialize Channel
		call	SUMBIT_CHAN_CMD	; SI = channel register	block
					; AL = command
		pop	si
		pop	bp
		retn
CHANNEL_INIT_RX	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FD85A	proc near		; CODE XREF: sub_FD038p

var_A		= byte ptr -0Ah
var_8		= word ptr -8
var_6		= word ptr -6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 6
		mov	byte ptr [bp+var_8], 2Dh ; '-'
		mov	[bp+var_A], 1
		mov	di, 1
		push	di
		call	PRINT_STH
		add	sp, 2
		call	sub_FDC68
		test	ax, ax
		jz	short loc_FD885
		cmp	COMMAND_CHAR, 0Dh
		jz	short loc_FD890
		call	ERROR_CONSOLE

loc_FD885:				; CODE XREF: sub_FD85A+1Fj
					; sub_FD85A+3Aj
		jmp	COMMON_RETURN
; ───────────────────────────────────────────────────────────────────────────

loc_FD888:				; CODE XREF: sub_FD85A+7Fj
					; sub_FD85A+8Dj
		mov	[bp+var_A], 0

loc_FD88C:				; CODE XREF: sub_FD85A+65j
					; sub_FD85A+6Cj ...
		inc	SYSCALL_ARG_OFF

loc_FD890:				; CODE XREF: sub_FD85A+26j
		cmp	[bp+var_A], 0
		jz	short loc_FD885
		call	sub_FDB72
		call	GET_SYSCALL_ARG_BYTE ; BX = offset
		mov	byte ptr [bp+var_6], al
		mov	al, byte ptr [bp+var_6]
		cbw
		push	ax
		call	PRINT_HEX_STAT
		add	sp, 2
		lea	di, [bp+var_8]
		push	di
		call	PUTCHAR_CONSOLE
		add	sp, 2
		call	READ_CHAR_TO_AL
		mov	COMMAND_CHAR, al
		cmp	COMMAND_CHAR, 20h ; ' '
		jz	short loc_FD88C
		cmp	COMMAND_CHAR, 0Dh
		jz	short loc_FD88C
		lea	di, [bp+var_6]
		push	di
		mov	al, COMMAND_CHAR
		cbw
		push	ax
		call	sub_FD944
		add	sp, 4
		test	ax, ax
		jz	short loc_FD888
		lea	di, [bp+var_6]
		push	di
		call	sub_FCB5E
		add	sp, 2
		test	ax, ax
		jz	short loc_FD888
		mov	al, byte ptr [bp+var_6]
		cbw
		push	ax
		call	SYSCALL_ARG_PUT_VALUE ;	Value on stack
		add	sp, 2
		call	GET_SYSCALL_ARG_BYTE ; BX = offset
		mov	di, ax
		mov	al, byte ptr [bp+var_6]
		cbw
		cmp	di, ax
		jz	short loc_FD88C
		call	ERROR_CONSOLE
		jmp	short loc_FD88C
sub_FD85A	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FD906	proc near		; CODE XREF: sub_FD05Ap

var_6		= word ptr -6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 2
		mov	di, 1
		push	di
		call	PRINT_STH
		add	sp, 2
		lea	di, [bp+var_6]
		push	di
		call	sub_FDC92
		add	sp, 2
		test	ax, ax
		jz	short loc_FD93D
		cmp	byte ptr [bp+var_6], 0
		jl	short loc_FD93D
		cmp	byte ptr [bp+var_6], 5
		jg	short loc_FD93D
		mov	al, byte ptr [bp+var_6]
		cbw
		push	ax
		call	DO_DISK_BOOT
		add	sp, 2

loc_FD93D:				; CODE XREF: sub_FD906+1Ej
					; sub_FD906+24j ...
		call	ERROR_CONSOLE
		jmp	COMMON_RETURN
sub_FD906	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FD944	proc near		; CODE XREF: sub_FCAA2+4Bp
					; sub_FCB5E+45p ...

var_6		= byte ptr -6
arg_0		= byte ptr  4
arg_2		= word ptr  6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 2
		mov	[bp+var_6], 1
		cmp	[bp+arg_0], 66h	; 'f'
		jg	short loc_FD98E
		cmp	[bp+arg_0], 61h	; 'a'
		jl	short loc_FD98E
		mov	bx, [bp+arg_2]
		mov	al, [bp+arg_0]
		cbw
		add	ax, 0FFA9h
		jmp	short loc_FD98A
; ───────────────────────────────────────────────────────────────────────────

loc_FD968:				; CODE XREF: sub_FD944+4Ej
		cmp	[bp+arg_0], 41h	; 'A'
		jl	short loc_FD994
		mov	bx, [bp+arg_2]
		mov	al, [bp+arg_0]
		cbw
		add	ax, 0FFC9h
		jmp	short loc_FD98A
; ───────────────────────────────────────────────────────────────────────────

loc_FD97A:				; CODE XREF: sub_FD944+54j
		cmp	[bp+arg_0], 30h	; '0'
		jl	short loc_FD99A
		mov	bx, [bp+arg_2]
		mov	al, [bp+arg_0]
		cbw
		add	ax, 0FFD0h

loc_FD98A:				; CODE XREF: sub_FD944+22j
					; sub_FD944+34j
		mov	[bx], al
		jmp	short loc_FD99E
; ───────────────────────────────────────────────────────────────────────────

loc_FD98E:				; CODE XREF: sub_FD944+10j
					; sub_FD944+16j
		cmp	[bp+arg_0], 46h	; 'F'
		jle	short loc_FD968

loc_FD994:				; CODE XREF: sub_FD944+28j
		cmp	[bp+arg_0], 39h	; '9'
		jle	short loc_FD97A

loc_FD99A:				; CODE XREF: sub_FD944+3Aj
		mov	[bp+var_6], 0

loc_FD99E:				; CODE XREF: sub_FD944+48j
		mov	al, [bp+var_6]
		cbw
		jmp	COMMON_RETURN
sub_FD944	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FD9A6	proc near		; CODE XREF: READ_CHAR_TO_AL+8p
					; sub_FCAA2+2Bp ...

var_6		= word ptr -6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 2
		lea	di, [bp+var_6]
		push	di
		mov	di, 1
		push	di
		sub	di, di
		push	di
		call	CHANNEL_RX
		add	sp, 6
		mov	al, byte ptr [bp+var_6]
		cbw
		jmp	COMMON_RETURN
sub_FD9A6	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

PUTCHAR_CONSOLE	proc near		; CODE XREF: DO_DISK_BOOT+AAp
					; READ_CHAR_TO_AL+12p ...

CHARACTER	= word ptr  4

		push	bp
		mov	bp, sp
		push	di
		push	si
		push	[bp+CHARACTER]
		mov	di, 1		; Length
		push	di
		sub	di, di
		push	di
		call	PUTS_CONSOLE
		add	sp, 6
		jmp	COMMON_RETURN
PUTCHAR_CONSOLE	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FD9DE	proc near		; CODE XREF: sub_FD042p

var_18		= word ptr -18h
var_16		= byte ptr -16h
var_15		= byte ptr -15h
var_14		= byte ptr -14h
var_13		= byte ptr -13h
var_12		= byte ptr -12h
var_11		= byte ptr -11h
var_10		= byte ptr -10h
var_F		= byte ptr -0Fh
var_E		= byte ptr -0Eh
var_D		= byte ptr -0Dh
var_C		= byte ptr -0Ch
var_B		= byte ptr -0Bh
var_A		= byte ptr -0Ah
var_9		= byte ptr -9
var_8		= word ptr -8
var_6		= byte ptr -6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 14h
		mov	byte ptr [bp+var_18], 0
		mov	byte ptr [bp+var_18+1],	2
		mov	[bp+var_16], 4
		mov	[bp+var_15], 6
		mov	[bp+var_14], 9
		mov	[bp+var_13], 0Bh
		mov	[bp+var_12], 0Dh
		mov	[bp+var_11], 0Fh
		mov	[bp+var_10], 12h
		mov	[bp+var_F], 14h
		mov	[bp+var_E], 16h
		mov	[bp+var_D], 18h
		mov	[bp+var_C], 1Bh
		mov	[bp+var_B], 1Dh
		mov	[bp+var_A], 1Fh
		mov	[bp+var_9], 21h	; '!'
		mov	di, 1
		push	di
		call	PRINT_STH
		add	sp, 2
		call	sub_FDC68
		test	ax, ax
		jnz	short loc_FDA3A
		jmp	loc_FDB01
; ───────────────────────────────────────────────────────────────────────────

loc_FDA3A:				; CODE XREF: sub_FD9DE+57j
		cmp	COMMAND_CHAR, 0Dh
		jnz	short loc_FDA48
		mov	[bp+var_8], 1
		jmp	short loc_FDA59
; ───────────────────────────────────────────────────────────────────────────

loc_FDA48:				; CODE XREF: sub_FD9DE+61j
		lea	di, [bp+var_8]
		push	di
		call	SET_VALUE
		add	sp, 2
		test	ax, ax
		jnz	short loc_FDA59
		jmp	loc_FDB01
; ───────────────────────────────────────────────────────────────────────────

loc_FDA59:				; CODE XREF: sub_FD9DE+68j
					; sub_FD9DE+76j
		call	sub_FDB72
		lea	di, [bp+var_18]
		mov	si, SYSCALL_ARG_OFF
		and	si, 0Fh
		add	di, si
		mov	al, [di]
		cbw
		push	ax
		call	PRINT_STH
		add	sp, 2

loc_FDA73:				; CODE XREF: sub_FD9DE+F1j
		cmp	[bp+var_8], 0
		jz	short loc_FDAD4
		call	GET_SYSCALL_ARG_BYTE ; BX = offset
		mov	[bp+var_6], al
		mov	al, [bp+var_6]
		cbw
		push	ax
		call	PRINT_HEX_STAT
		add	sp, 2
		inc	SYSCALL_ARG_OFF
		dec	[bp+var_8]
		test	SYSCALL_ARG_OFF, 3
		jnz	short loc_FDAA3
		mov	di, 1
		push	di
		call	PRINT_STH
		add	sp, 2

loc_FDAA3:				; CODE XREF: sub_FD9DE+B9j
		test	SYSCALL_ARG_OFF, 0Fh
		jnz	short loc_FDABB
		dec	SYSCALL_ARG_OFF
		call	sub_FDB04
		cmp	[bp+var_8], 0
		jz	short loc_FDABB
		call	sub_FDB72

loc_FDABB:				; CODE XREF: sub_FD9DE+CBj
					; sub_FD9DE+D8j
		mov	al, COMMAND_CHAR
		cbw
		push	ax
		mov	di, 0FFFFh
		push	di
		sub	di, di
		push	di
		call	CHANNEL_RX
		add	sp, 6
		test	ax, ax
		jz	short loc_FDA73
		call	sub_FD9A6

loc_FDAD4:				; CODE XREF: sub_FD9DE+99j
		test	SYSCALL_ARG_OFF, 0Fh
		jz	short loc_FDB01
		mov	di, 24h	; '$'
		lea	si, [bp+var_18]
		mov	dx, SYSCALL_ARG_OFF
		and	dx, 0Fh
		add	si, dx
		mov	al, [si]
		cbw
		sub	di, ax
		push	di
		call	PRINT_STH
		add	sp, 2
		and	SYSCALL_ARG_OFF, 0FFF0h
		call	sub_FDB04

loc_FDB01:				; CODE XREF: sub_FD9DE+59j
					; sub_FD9DE+78j ...
		jmp	COMMON_RETURN
sub_FD9DE	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FDB04	proc near		; CODE XREF: sub_FD9DE+D1p
					; sub_FD9DE+120p

var_C		= word ptr -0Ch
var_A		= word ptr -0Ah
var_8		= word ptr -8
var_6		= word ptr -6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 8
		mov	byte ptr [bp+var_6], 2Ah ; '*'
		mov	byte ptr [bp+var_8], 2Eh ; '.'
		mov	di, 2
		push	di
		call	PRINT_STH
		add	sp, 2
		lea	di, [bp+var_6]
		push	di
		call	PUTCHAR_CONSOLE
		add	sp, 2
		and	SYSCALL_ARG_OFF, 0FFF0h
		mov	[bp+var_C], 0

loc_FDB33:				; CODE XREF: sub_FDB04+5Fj
		call	GET_SYSCALL_ARG_BYTE ; BX = offset
		and	ax, 7Fh
		mov	byte ptr [bp+var_A], al
		cmp	byte ptr [bp+var_A], 20h ; ' '
		jl	short loc_FDB48
		cmp	byte ptr [bp+var_A], 7Eh ; '~'
		jle	short loc_FDB4E

loc_FDB48:				; CODE XREF: sub_FDB04+3Cj
		lea	di, [bp+var_8]
		push	di
		jmp	short loc_FDB52
; ───────────────────────────────────────────────────────────────────────────

loc_FDB4E:				; CODE XREF: sub_FDB04+42j
		lea	di, [bp+var_A]
		push	di

loc_FDB52:				; CODE XREF: sub_FDB04+48j
		call	PUTCHAR_CONSOLE
		add	sp, 2
		inc	SYSCALL_ARG_OFF
		inc	[bp+var_C]
		cmp	[bp+var_C], 0Fh
		jle	short loc_FDB33
		lea	di, [bp+var_6]
		push	di
		call	PUTCHAR_CONSOLE
		add	sp, 2
		jmp	COMMON_RETURN
sub_FDB04	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FDB72	proc near		; CODE XREF: sub_FD85A+3Cp
					; sub_FD9DE:loc_FDA59p	...

var_6		= word ptr -6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 2
		mov	byte ptr [bp+var_6], 3Ah ; ':'
		call	sub_FD342
		push	SYSCALL_ARG_SEG
		call	sub_FD2E6
		add	sp, 2
		lea	di, [bp+var_6]
		push	di
		call	PUTCHAR_CONSOLE
		add	sp, 2
		push	SYSCALL_ARG_OFF
		call	sub_FD2E6
		add	sp, 2
		mov	di, 2
		push	di
		call	PRINT_STH
		add	sp, 2
		jmp	COMMON_RETURN
sub_FDB72	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FDBAC	proc near		; CODE XREF: CHANNEL_IO+CCp
					; CHANNEL_IO+D8p ...

var_A		= word ptr -0Ah
var_8		= word ptr -8
var_6		= word ptr -6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 6
		call	sub_FDC06
		mov	[bp+var_8], ax
		call	sub_FDC06
		mov	[bp+var_A], ax
		lea	di, [bp+var_6]
		push	di
		push	ax
		push	[bp+var_8]
		call	sub_FDCDA
		add	sp, 6
		test	ax, ax
		jz	short loc_FDBDF
		mov	di, [bp+var_6]
		and	di, 0FFh
		add	word_F28, di
		jmp	short loc_FDBE2
; ───────────────────────────────────────────────────────────────────────────

loc_FDBDF:				; CODE XREF: sub_FDBAC+24j
		call	ERROR_CONSOLE

loc_FDBE2:				; CODE XREF: sub_FDBAC+31j
		mov	ax, [bp+var_6]
		jmp	COMMON_RETURN
sub_FDBAC	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FDBE8	proc near		; CODE XREF: CHANNEL_IO+D2p
					; CHANNEL_IO:loc_FCEA3p ...

var_6		= word ptr -6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 2
		call	sub_FDBAC
		mov	cx, 8
		shl	ax, cl
		push	ax
		call	sub_FDBAC
		pop	bx
		add	ax, bx
		mov	[bp+var_6], ax
		jmp	COMMON_RETURN
sub_FDBE8	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FDC06	proc near		; CODE XREF: CHANNEL_IO:loc_FCE18p
					; sub_FDBAC+8p	...

var_6		= word ptr -6

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 6
		mov	di, word_F26
		cmp	word_F22, di
		jb	short loc_FDC55
		cmp	word_F24, 12Ch
		jbe	short loc_FDC2E
		mov	word_F26, 12Ch
		sub	word_F24, 12Ch
		jmp	short loc_FDC3C
; ───────────────────────────────────────────────────────────────────────────

loc_FDC2E:				; CODE XREF: sub_FDC06+18j
		mov	di, word_F24
		mov	word_F26, di
		mov	word_F24, 0

loc_FDC3C:				; CODE XREF: sub_FDC06+26j
		mov	di, offset BOOT_SECTOR_BUF ; While overlaying the IO progrem this RAM area does	not
					; seem to be passed to the IOP.	Instead, it is used as a
					; buffer to read the boot sectors in from the FD & HD.
		push	di
		push	word_F26
		mov	al, byte_512
		cbw
		push	ax
		call	CHANNEL_RX
		add	sp, 6
		mov	word_F22, 0

loc_FDC55:				; CODE XREF: sub_FDC06+10j
		mov	di, word_F22
		mov	al, BOOT_SECTOR_BUF[di]	; While	overlaying the IO progrem this RAM area	does not
					; seem to be passed to the IOP.	Instead, it is used as a
					; buffer to read the boot sectors in from the FD & HD.
		cbw
		mov	[bp+var_6], ax
		inc	word_F22
		jmp	COMMON_RETURN
sub_FDC06	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FDC68	proc near		; CODE XREF: sub_FD0CE+12p
					; sub_FD0CE+33p ...
		push	bp
		mov	bp, sp
		push	di
		push	si
		call	READ_CHAR_TO_AL
		mov	COMMAND_CHAR, al
		call	sub_FCA34
		jmp	COMMON_RETURN
sub_FDC68	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

SET_VALUE	proc near		; CODE XREF: sub_FD0CE+53p
					; HANDLE_IO_COMMAND+35p ...

IOPORT_ADDR	= word ptr  4

		push	bp
		mov	bp, sp
		push	di
		push	si
		call	READ_CHAR_TO_AL
		mov	COMMAND_CHAR, al
		push	[bp+IOPORT_ADDR]
		call	sub_FCAA2
		add	sp, 2
		jmp	COMMON_RETURN
SET_VALUE	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FDC92	proc near		; CODE XREF: sub_FD554+9Bp
					; sub_FD906+16p

arg_0		= word ptr  4

		push	bp
		mov	bp, sp
		push	di
		push	si
		call	READ_CHAR_TO_AL
		mov	COMMAND_CHAR, al
		push	[bp+arg_0]
		call	sub_FCB5E
		add	sp, 2
		jmp	COMMON_RETURN
sub_FDC92	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

DO_INB		proc near		; CODE XREF: HANDLE_IO_COMMAND+77p

IOPORT_ADDR	= word ptr  4

		push	bp
		mov	bp, sp
		mov	dx, [bp+IOPORT_ADDR]
		in	al, dx
		pop	bp
		retn
DO_INB		endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

DO_INW		proc near		; CODE XREF: HANDLE_IO_COMMAND+58p

IOPORT_ADDR	= word ptr  4

		push	bp
		mov	bp, sp
		mov	dx, [bp+IOPORT_ADDR]
		in	ax, dx
		pop	bp
		retn
DO_INW		endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

DO_OUTB		proc near		; CODE XREF: HANDLE_IO_COMMAND+ABp

IOPORT_ADDR	= word ptr  4
BYTE_VAL	= byte ptr  6

		push	bp
		mov	bp, sp
		mov	dx, [bp+IOPORT_ADDR]
		mov	al, [bp+BYTE_VAL]
		out	dx, al
		pop	bp
		retn
DO_OUTB		endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

DO_OUTW		proc near		; CODE XREF: HANDLE_IO_COMMAND+9Dp

IOPORT_ADDR	= word ptr  4
WORD_VAL	= word ptr  6

		push	bp
		mov	bp, sp
		mov	dx, [bp+IOPORT_ADDR]
		mov	ax, [bp+WORD_VAL]
		out	dx, ax
		pop	bp
		retn
DO_OUTW		endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


INC_NEW_CMD_REG	proc near		; CODE XREF: CHANNEL_RX+47p
					; CHANNEL_RX+7Cp ...
		inc	NEW_CMD_REG
		retn
INC_NEW_CMD_REG	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: bp-based frame

sub_FDCDA	proc near		; CODE XREF: sub_FDBAC+1Cp

var_A		= word ptr -0Ah
var_8		= word ptr -8
var_6		= byte ptr -6
var_4		= word ptr -4
arg_0		= byte ptr  4
arg_2		= byte ptr  6
arg_4		= word ptr  8

		push	bp
		mov	bp, sp
		push	di
		push	si
		sub	sp, 6
		mov	[bp+var_6], 1
		lea	di, [bp+var_8]
		push	di
		mov	al, [bp+arg_0]
		cbw
		push	ax
		call	sub_FD944
		add	sp, 4
		mov	[bp+var_6], al
		cmp	[bp+var_6], 0
		jz	short loc_FDD11
		lea	di, [bp+var_A]
		push	di
		mov	al, [bp+arg_2]
		cbw
		push	ax
		call	sub_FD944
		add	sp, 4
		test	ax, ax
		jnz	short loc_FDD15

loc_FDD11:				; CODE XREF: sub_FDCDA+22j
		sub	di, di
		jmp	short loc_FDD18
; ───────────────────────────────────────────────────────────────────────────

loc_FDD15:				; CODE XREF: sub_FDCDA+35j
		mov	di, 1

loc_FDD18:				; CODE XREF: sub_FDCDA+39j
		mov	dx, di
		mov	[bp+var_6], dl
		mov	bx, [bp+arg_4]
		mov	al, byte ptr [bp+var_8]
		cbw
		mov	cx, 4
		shl	ax, cl
		mov	dx, ax
		mov	al, byte ptr [bp+var_A]
		cbw
		add	dx, ax
		mov	[bx], dl
		mov	al, [bp+var_6]
		cbw
		jmp	$+3
sub_FDCDA	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


COMMON_RETURN	proc near		; CODE XREF: DO_GETCHAR:loc_FC3E6j
					; DO_PUTCHAR+17j ...
		lea	sp, [bp-4]
		pop	si
		pop	di
		pop	bp
		retn
COMMON_RETURN	endp ; sp =  6

; ───────────────────────────────────────────────────────────────────────────
		db 2BFh	dup(   0)

; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


SYSCALL_ENTRY	proc near
		jmp	far ptr	SYSCALL_TRAMPOLINE
SYSCALL_ENTRY	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: thunk

POST_TRAMPOLINE	proc near		; CODE XREF: ENTRY:loc_FC029J
		jmp	POST
POST_TRAMPOLINE	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: thunk

SETUP_INTC1_TRAMPOLINE proc near	; CODE XREF: SETUP_INTC1_TRAMPOLINE_2J
		jmp	SETUP_IRQS
SETUP_INTC1_TRAMPOLINE endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████

; Attributes: thunk

POKE_IOP1_TRAMPOLINE proc near		; CODE XREF: POKE_IOP1_TRAMPOLINE2J
		jmp	POKE_IOP1
POKE_IOP1_TRAMPOLINE endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


POST		proc near		; CODE XREF: POST_TRAMPOLINEj
		mov	ax, 0FC00h
		mov	ds, ax
		assume ds:ROM
		xor	bx, bx
		xor	al, al
		mov	cx, 4000h

loc_FE01A:				; CODE XREF: POST+Fj
		add	al, [bx]
		inc	bx
		loop	loc_FE01A
		and	al, al
		jz	short loc_FE027
		mov	bl, 1		; POST error 1 -- BIOS checksum	failed
		jmp	short loc_FE049
; ───────────────────────────────────────────────────────────────────────────

loc_FE027:				; CODE XREF: POST+13j
		mov	cx, 11h
		xor	si, si
		mov	dx, 200h
		stc

loc_FE030:				; CODE XREF: POST+35j
		mov	ax, si
		mov	bx, si
		out	dx, ax		; MMU Memory Management	Ports
		in	ax, dx		; MMU Memory Management	Ports
		rcl	si, 1
		and	ax, 0F8FFh
		and	bx, 0F8FFh
		cmp	ax, bx
		jnz	short POST_FAILED_02
		loop	loc_FE030
		jmp	short loc_FE04B
; ───────────────────────────────────────────────────────────────────────────

POST_FAILED_02:				; CODE XREF: POST+33j
		mov	bl, 2		; POST failed 2	-- MMU port readback bad

loc_FE049:				; CODE XREF: POST+17j
		jmp	short loc_FE08A
; ───────────────────────────────────────────────────────────────────────────

loc_FE04B:				; CODE XREF: POST+37j
		mov	cx, 9
		mov	dx, 200h
		xor	ax, ax
		mov	bx, 1

loc_FE056:				; CODE XREF: POST+51j
		out	dx, ax		; MMU Memory Management	Ports
		rcl	bx, 1
		mov	dx, bx
		add	dx, 200h
		loop	loc_FE056
		mov	cx, 9
		mov	dx, 200h
		mov	bx, 1

loc_FE06A:				; CODE XREF: POST+76j
		in	ax, dx		; MMU Memory Management	Ports
		and	ax, 0F8FFh
		jnz	short POST_FAILED_03
		not	ax
		out	dx, ax		; MMU Memory Management	Ports
		in	ax, dx		; MMU Memory Management	Ports
		and	ax, 0F8FFh
		cmp	ax, 0F8FFh
		jnz	short POST_FAILED_03
		rcl	bx, 1
		mov	dx, bx
		add	dx, 200h
		loop	loc_FE06A
		jmp	short loc_FE08C
; ───────────────────────────────────────────────────────────────────────────

POST_FAILED_03:				; CODE XREF: POST+60j POST+6Cj
		mov	bl, 3		; POST error 3 -- MMU port error

loc_FE08A:				; CODE XREF: POST:loc_FE049j
		jmp	short loc_FE0B9
; ───────────────────────────────────────────────────────────────────────────

loc_FE08C:				; CODE XREF: POST+78j
		mov	cx, 100h
		mov	dx, 200h
		xor	ax, ax

loc_FE094:				; CODE XREF: POST+89j
		out	dx, ax		; MMU Memory Management	Ports
		inc	dx
		inc	dx
		loop	loc_FE094
		mov	cx, 100h
		mov	dx, 200h

loc_FE09F:				; CODE XREF: POST+A5j
		in	ax, dx		; MMU Memory Management	Ports
		and	ax, 0F8FFh
		jnz	short POST_FAILED_04
		not	ax
		out	dx, ax		; MMU Memory Management	Ports
		in	ax, dx		; MMU Memory Management	Ports
		and	ax, 0F8FFh
		cmp	ax, 0F8FFh
		jnz	short POST_FAILED_04
		inc	dx
		inc	dx
		loop	loc_FE09F
		jmp	short loc_FE0BB
; ───────────────────────────────────────────────────────────────────────────

POST_FAILED_04:				; CODE XREF: POST+95j POST+A1j
		mov	bl, 4		; POST error 4 -- MMU port readback bad

loc_FE0B9:				; CODE XREF: POST:loc_FE08Aj
		jmp	short loc_FE0DD
; ───────────────────────────────────────────────────────────────────────────

loc_FE0BB:				; CODE XREF: POST+A7j
		lea	di, loc_FE0C2
		jmp	INIT_MEMORY_MAPPING
; ───────────────────────────────────────────────────────────────────────────

loc_FE0C2:				; DATA XREF: POST:loc_FE0BBo
		xor	ax, ax
		mov	ds, ax
		assume ds:ZERO
		mov	INT0_OFF, ax
		mov	cx, 11h
		mov	dx, ax
		mov	ax, 1

loc_FE0D1:				; CODE XREF: POST+D6j
		mov	INT0_OFF, dx
		cmp	INT0_OFF, dx
		jz	short loc_FE0E0
		mov	bl, 5		; POST error 5 --

loc_FE0DD:				; CODE XREF: POST:loc_FE0B9j
		jmp	GO_LOW_INIT
; ───────────────────────────────────────────────────────────────────────────

loc_FE0E0:				; CODE XREF: POST+CBj
		mov	dx, ax
		shl	ax, 1
		loop	loc_FE0D1
		lea	di, loc_FE0ED
		jmp	SWITCH_STACK
; ───────────────────────────────────────────────────────────────────────────

loc_FE0ED:				; DATA XREF: POST+D8o
		mov	si, 20h	; ' '
		and	ax, ax
		jz	short loc_FE0F7
		mov	si, 3Fh	; '?'

loc_FE0F7:				; CODE XREF: POST+E4j
		mov	bp, si
		xor	ax, ax
		lea	di, RET_5

loc_FE0FF:				; CODE XREF: POST+F7j
		jmp	short loc_FE119
; ───────────────────────────────────────────────────────────────────────────

RET_5:					; DATA XREF: POST+EDo
		add	ax, 400h
		dec	si
		jnz	short loc_FE0FF
		mov	si, bp
		xor	ax, ax
		lea	di, RET_6

loc_FE10F:				; CODE XREF: POST+107j
		jmp	short loc_FE12B
; ───────────────────────────────────────────────────────────────────────────

RET_6:					; DATA XREF: POST+FDo
		add	ax, 400h
		dec	si
		jnz	short loc_FE10F
		jmp	short loc_FE152
; ───────────────────────────────────────────────────────────────────────────

loc_FE119:				; CODE XREF: POST:loc_FE0FFj
		mov	cx, 0Fh
		xor	bx, bx
		mov	ds, ax
		assume ds:nothing
		mov	dl, 55h	; 'U'
		stc

loc_FE123:				; CODE XREF: POST+119j
		mov	[bx], dl
		rcl	bx, 1
		loop	loc_FE123
		jmp	di
; ───────────────────────────────────────────────────────────────────────────

loc_FE12B:				; CODE XREF: POST:loc_FE10Fj
		mov	cx, 0Fh
		xor	bx, bx
		mov	bp, 1
		mov	ds, ax
		mov	dl, 55h	; 'U'

loc_FE137:				; CODE XREF: POST+13Bj
		cmp	[bx], dl
		jnz	short POST_FAILED_06
		not	dl
		mov	[bx], dl
		cmp	[bx], dl
		jnz	short POST_FAILED_06
		not	dl
		mov	bx, bp
		shl	bp, 1
		loop	loc_FE137
		jmp	di
; ───────────────────────────────────────────────────────────────────────────

POST_FAILED_06:				; CODE XREF: POST+12Bj	POST+133j
		mov	bl, 6		; POST error 6 --
		jmp	loc_FE206
; ───────────────────────────────────────────────────────────────────────────

loc_FE152:				; CODE XREF: POST+109j
		mov	ax, 0FFFFh
		xor	di, di
		mov	es, di
		mov	ds, di
		assume ds:ZERO
		mov	cx, 1000h
		rep stosw
		mov	dx, ax
		lea	di, loc_FE169
		jmp	INIT_TIMERS_INTERRUPTS
; ───────────────────────────────────────────────────────────────────────────

loc_FE169:				; DATA XREF: POST+154o
		cld
		lea	di, loc_FE171
		jmp	SWITCH_STACK
; ───────────────────────────────────────────────────────────────────────────

loc_FE171:				; DATA XREF: POST+15Co
		mov	bl, 3Eh	; '>'
		and	ax, ax
		jz	short loc_FE179
		mov	bl, 7Dh	; '}'

loc_FE179:				; CODE XREF: POST+167j
		xor	ax, ax
		mov	ds, ax
		mov	IOP1_PTR.CCW, bl
		xor	ax, ax
		mov	ss, ax
		mov	sp, 1000h
		lea	di, INT2_NMI_HANDLER
		mov	INT2_NMI_OFF, di
		mov	INT2_NMI_SEG, cs
		in	ax, 70h		; MMU Clear Violation Port
		mov	ax, 4
		out	58h, ax		; Z80A I/O Processor Chan att.
		mov	dx, 101h
		lea	bp, loc_FE1A5
		jmp	loc_FE1B1
; ───────────────────────────────────────────────────────────────────────────

loc_FE1A5:				; DATA XREF: POST+190o
		mov	dx, 0FFFFh
		lea	bp, loc_FE1AF
		jmp	loc_FE1B1
; ───────────────────────────────────────────────────────────────────────────

loc_FE1AF:				; DATA XREF: POST+19Ao
		jmp	short loc_FE208
; ───────────────────────────────────────────────────────────────────────────

loc_FE1B1:				; CODE XREF: POST+194j	POST+19Ej
		xor	ax, ax
		mov	ds, ax
		mov	bl, IOP1_PTR.CCW
		mov	ax, 200h

loc_FE1BC:				; CODE XREF: POST+1C0j
		mov	es, ax
		assume es:nothing
		mov	ax, dx
		xor	di, di
		mov	cx, 1000h
		rep stosw
		mov	ax, es
		add	ax, 200h
		dec	bl
		jnz	short loc_FE1BC
		mov	bl, IOP1_PTR.CCW
		mov	ax, 200h

loc_FE1D7:				; CODE XREF: POST+1D9j
		mov	ds, ax
		assume ds:nothing
		lea	di, loc_FE1E0
		jmp	INIT_TIMERS_INTERRUPTS
; ───────────────────────────────────────────────────────────────────────────

loc_FE1E0:				; DATA XREF: POST+1CBo
		mov	ax, ds
		add	ax, 200h
		dec	bl
		jnz	short loc_FE1D7
		jmp	bp
; ───────────────────────────────────────────────────────────────────────────

INIT_TIMERS_INTERRUPTS:			; CODE XREF: POST+158j	POST+1CFj
		mov	cx, 1000h
		xor	si, si

loc_FE1F0:				; CODE XREF: POST+1F2j
		cmp	[si], dx
		jnz	short POST_FAILED_07
		not	dx
		mov	[si], dx
		cmp	[si], dx
		jnz	short POST_FAILED_07
		not	dx
		inc	si
		inc	si
		loop	loc_FE1F0
		jmp	di
; ───────────────────────────────────────────────────────────────────────────

POST_FAILED_07:				; CODE XREF: POST+1E4j	POST+1ECj
		mov	bl, 7		; POST error 7 -- ???

loc_FE206:				; CODE XREF: POST+141j
		jmp	short loc_FE224
; ───────────────────────────────────────────────────────────────────────────

loc_FE208:				; CODE XREF: POST:loc_FE1AFj
		mov	al, 70h	; 'p'
		mov	dx, 101h
		out	dx, al		; 8254 Timer Control Word Register - Write Only
		mov	ax, 0AAh ; '¬'
		mov	dx, 105h
		out	dx, al		; 8254 Timer Counter 1
		mov	cx, ax

loc_FE217:				; CODE XREF: POST:loc_FE217j
		loop	loc_FE217
		in	al, dx		; 8254 Timer Counter 1
		mov	ah, al
		in	al, dx		; 8254 Timer Counter 1
		cmp	ax, 0AAAAh
		jnz	short loc_FE227
		mov	bl, 8		; POST error 8 -- Timer	error?

loc_FE224:				; CODE XREF: POST:loc_FE206j
		jmp	loc_FE29B
; ───────────────────────────────────────────────────────────────────────────

loc_FE227:				; CODE XREF: POST+212j
		mov	al, 70h	; 'p'
		mov	dx, 101h
		out	dx, al		; 8254 Timer Control Word Register - Write Only
		mov	dx, 105h
		out	dx, al		; 8254 Timer Counter 1
		mov	ax, 1F00h
		mov	ss, ax
		assume ss:nothing
		mov	sp, 0FFh
		mov	cx, 100h
		lea	dx, ds:32Ah
		xor	bx, bx
		mov	ds, bx
		assume ds:ZERO

loc_FE244:				; CODE XREF: POST+23Ej
		mov	[bx], dx
		inc	bx
		inc	bx
		mov	word ptr [bx], cs
		inc	bx
		inc	bx
		loop	loc_FE244
		lea	di, INT2_NMI_HANDLER
		mov	INT2_NMI_OFF, di
		mov	INT2_NMI_SEG, cs
		lea	dx, INT33_TEST_TIMER_HANDLER ; Puts 0x21 to BH and 1 to	CX to terminate	the test loop
		mov	INT33_TIMER_OFF, dx
		mov	INT33_TIMER_SEG, cs
		mov	al, 13h
		out	82h, al		; PIC ICW1, OCW2, or OCW3
		mov	al, 20h	; ' '
		mov	dx, 80h	; 'Ç'
		out	dx, al		; PIC ICW2, ICW3, ICW4,	or OCW1
		mov	al, 3
		out	dx, al		; PIC ICW2, ICW3, ICW4,	or OCW1
		mov	al, 71h	; 'q'
		out	dx, al		; PIC ICW2, ICW3, ICW4,	or OCW1
		sti
		mov	al, 56h	; 'V'
		mov	dx, 101h
		out	dx, al		; 8254 Timer Control Word Register - Write Only
		mov	al, 90h	; 'É'
		out	dx, al		; 8254 Timer Control Word Register - Write Only
		mov	al, 50h	; 'P'
		mov	dx, 105h
		out	dx, al		; 8254 Timer Counter 1
		mov	dx, 103h
		out	dx, al		; 8254 Timer Counter 2
		mov	bh, 0FFh
		mov	cx, 1FFFh

loc_FE28F:				; CODE XREF: POST+283j
		mul	si
		loop	loc_FE28F
		cli
		cmp	bh, 21h	; '!'
		jz	short POKE_IOP1
		mov	bl, 9		; POST error 9 --

loc_FE29B:				; CODE XREF: POST:loc_FE224j
		jmp	SETUP_AND_INST_DEF_IRQ
; ───────────────────────────────────────────────────────────────────────────

POKE_IOP1:				; CODE XREF: POKE_IOP1_TRAMPOLINEj
					; POST+289j
		xor	ax, ax
		mov	ds, ax
		mov	IOP_00_OPCODE, 90h ; 'É' ; HD/FD - command
		mov	byte ptr IOP_0D_STATUS,	0FFh ; FD/HD - Operation status. (FF=not run, 00=success)
		mov	ax, 7000h	; IO PORT
		push	ax
		lea	ax, IOP_00_OPCODE ; HD/FD - command
		push	ax
		mov	ax, offset IOP1_PTR
		push	ax
		mov	IOP_IRQ_DOORBELL, 0FFh ; IR2/IR7 "Hard/Floppy Disk Interrupt" zero this	out
		call	IOP_SEND
		add	sp, 6
		mov	cx, 0

WAIT_FOR_IOP_DOORBELL:			; CODE XREF: POST+2C1j
		cmp	IOP_IRQ_DOORBELL, 0 ; IR2/IR7 "Hard/Floppy Disk	Interrupt" zero	this out
		jz	short DOORBELL_RUNG
		loop	WAIT_FOR_IOP_DOORBELL
		jmp	short loc_FE2DA
; ───────────────────────────────────────────────────────────────────────────

DOORBELL_RUNG:				; CODE XREF: POST+2BFj
		cmp	byte ptr IOP_0D_STATUS,	0 ; FD/HD - Operation status. (FF=not run, 00=success)
		jz	short SETUP_AND_INST_DEF_IRQ

loc_FE2DA:				; CODE XREF: POST+2C3j
		mov	bl, 0Bh		; POST error B -- Hard disk board timeout

SETUP_AND_INST_DEF_IRQ:			; CODE XREF: POST:loc_FE29Bj POST+2CAj
		push	bx
		mov	al, 80h	; 'Ç'
		or	bl, bl
		jnz	short loc_FE2EC
		cmp	byte_508, 0
		jnz	short loc_FE2EC
		mov	al, 0

loc_FE2EC:				; CODE XREF: POST+2D3j	POST+2DAj
		mov	INT34_IR2_HDD_PTR, al
		mov	cx, 256
		lea	dx, DEFAULT_HANDLER
		xor	bx, bx
		mov	ds, bx

loc_FE2FA:				; CODE XREF: POST+2F4j
		mov	[bx], dx
		inc	bx
		inc	bx
		mov	word ptr [bx], cs
		inc	bx
		inc	bx
		loop	loc_FE2FA
		pop	bx
		call	SETUP_IRQS

GO_LOW_INIT:				; CODE XREF: POST:loc_FE0DDj
		jmp	far ptr	LOW_INIT_TRAMPOLINE
POST		endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


SETUP_IRQS	proc near		; CODE XREF: SETUP_INTC1_TRAMPOLINEj
					; POST+2F7p
		push	dx
		lea	ax, INT2_NMI_HANDLER
		mov	INT2_NMI_OFF, ax
		mov	INT2_NMI_SEG, cs
		lea	ax, INT34_IR2_HDD_HANDLER_SIMPLE
		mov	INT34_IR2_HDD_OFF, ax
		mov	INT34_IR2_HDD_SEG, cs
		lea	ax, INT39_IR7_FDD_HANDLER
		mov	INT39_IR7_FDD_OFF, ax
		mov	INT39_IR7_FDD_SEG, cs
		mov	al, 13h
		out	82h, al		; PIC ICW1, OCW2, or OCW3
		mov	al, 20h	; ' '
		mov	dx, 80h	; 'Ç'
		out	dx, al		; PIC ICW2, ICW3, ICW4,	or OCW1
		mov	al, 3
		out	dx, al		; PIC ICW2, ICW3, ICW4,	or OCW1
		mov	al, 73h	; 's'
		out	dx, al		; PIC ICW2, ICW3, ICW4,	or OCW1
		pop	dx
		sti
		retn
SETUP_IRQS	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


INT39_IR7_FDD_HANDLER proc far		; DATA XREF: SETUP_IRQS+17o
		push	ds
		push	ax
		xor	ax, ax
		mov	ds, ax
		cmp	FDD_DOORBELL, 0
		jz	short IS_0
		push	bx
		push	si
		mov	si, offset IOP1_PTR.PB_SEG
		mov	bx, [si]
		inc	bx
		mov	al, [bx]	; Status
		and	al, 80h		; Still	busy?
		jnz	short loc_FE367
		mov	IOP_IRQ_DOORBELL, 0 ; IR2/IR7 "Hard/Floppy Disk	Interrupt" zero	this out
		mov	FDD_DOORBELL, 0

loc_FE367:				; CODE XREF: INT39_IR7_FDD_HANDLER+19j
		pop	si
		pop	bx

IS_0:					; CODE XREF: INT39_IR7_FDD_HANDLER+Bj
		pop	ax
		pop	ds
		iret
INT39_IR7_FDD_HANDLER endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


sub_FE36C	proc near		; CODE XREF: sub_FE36Cj
		jmp	short sub_FE36C
sub_FE36C	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


sub_FE36E	proc near		; CODE XREF: sub_FE36Ej
		jmp	short sub_FE36E
sub_FE36E	endp


; ███████████████ S U B	R O U T	I N E ███████████████████████████████████████


sub_FE370	proc near		; CODE XREF: sub_FE370j
		jmp	short sub_FE370
sub_FE370	endp

; ───────────────────────────────────────────────────────────────────────────
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0,86Fh dup(0FFh)
		db 0FFh
		db 0FFh
		db 40Eh	dup(0FFh)
DATA_ROM	db 1,0,0,0,'@',0,0,0,0,0,0,0,'┤~',0,0,0,0,0,0,0,0,'á',9,0,0Ah
					; DATA XREF: POST_FINISH+2Eo
		db 0,0,0,0,0,0,0,0,'┤■',0,0,0,0,0,0,0,0,'¬',9,0,0Ah
		db 0,0,0,0,0,0,0,0,'┤■',0,0,0,0,0,0,0,0,'┤',9,0,0Ah
		db 0,0,0,0,0,0,0,0,'┤■',0,0,0,0,0,0,0,0,'¥',9,0,0Ah
		db 0,0,0,0,0,0,0,0,'┤■',0,0,0,0,0,0,0,0,'╚',9,0,0Ah
		db 0,0,0,0,0,0,0,0,'┤■',0,0,0,0,0,0,0,0,'Ê',9,0,0Ah
		db 0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,2,0,2,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,2,6,0,0,0,0,0,0,0,0,0,0,0,0
		db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11h,11h,11h,11h,'""""',0,0,0FFh,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0Ch,0,0FFh,1Fh,2,0Ah
		db 'Monitor Version a2.2',0,0Ah
		db 'PASSED POWER-UP TEST',0,0Ah
		db 'FAILED POWER-UP TEST ',0,0,0,0Ah
		db 'Boot Failed, Status=',0,0Ah
		db 'Floppy command not supported.',0,0Ah
		db 'Floppy timeout error',0,0Ah
		db 'Hard disk command not supported.',0,0Ah
		db 'Hard disk timeout error',0,0Ah
		db 'Break ....',0,'COPYRIGHT ALTOS COMPUTER SYSTEMS',0,0Ah
		db 'Channel no.(0-4): ',0,' Ready- ',0,' -Done',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'AXBXCXDXSIDIDSESSSSPBPFL'
IOP8089_PROGRAM	db  51h, 30h,0D0h,0FFh	;	  movi	  gc,0ffd0h
		db 0AAh, 0BBh, 4, 20h	;	  jnbt	  [pp].4h,5,x3290
		db 0Ah,	4Eh, 6,	80h	;	  movbi	  [gc].6h,80h
		db 2, 93h, 8, 2, 0CEh, 2 ;	   movb	   [gc].2h,[pp].8h
		db 0EAh, 0BAh, 6, 0FCh	; x327a:  jnbt	  [gc].6h,7,x327a
		db 0Ah,	4Eh, 6,	20h	;	  movbi	  [gc].6h,20h
		db 13h,	4Fh, 14h, 2 dup(0) ;	     movi    [pp].14h,0h
		db 0Ah,	0BEh, 6, 0FCh	; x3287:  jbt	  [gc].6h,0,x3287
		db 12h,	0BAh, 4, 0E2h, 0 ;	   ljnbt   [gc].4h,0,x3372
		db 0Ah,	0CBh, 4, 0Fh	; x3290:  andbi	  [pp].4h,0fh
		db 12h,	0E7h, 4, 0B1h, 0 ;	   ljzb	   [pp].4h,x334a
		db 2, 93h, 8, 2, 0CEh, 2 ;	   movb	   [gc].2h,[pp].8h
		db 0EAh, 0BAh, 6, 0FCh	; x329f:  jnbt	  [gc].6h,7,x329f
		db 2, 93h, 14h,	0, 0CEh	;	  movb	  [gc],[pp].14h
		db 2, 93h, 15h,	0, 0CEh	;	  movb	  [gc],[pp].15h
		db 2, 93h, 6, 2, 0CEh, 4 ;	   movb	   [gc].4h,[pp].6h
		db 2, 93h, 7, 2, 0CEh, 4 ;	   movb	   [gc].4h,[pp].7h
		db 0Ah,	4Eh, 6,	10h	;	  movbi	  [gc].6h,10h
		db 3, 93h, 6, 3, 0CFh, 14h ;	     mov     [pp].14h,[pp].6h
		db 0Ah,	0BEh, 6, 0FCh	; x32c3:  jbt	  [gc].6h,0,x32c3
		db 2Ah,	0BAh, 4, 0FCh	; x32c7:  jnbt	  [gc].4h,1,x32c7
		db 0Ah,	0E7h, 10h, 7Bh	;	  jzb	  [pp].10h,x334a
		db 0Ah,	0BFh, 4, 0Eh	;	  jbt	  [pp].4h,0,x32e1
		db 3, 8Bh, 0Ch		;	  lpd	  ga,[pp].0ch
		db 31h,	30h, 2 dup(0)	;	  movi	  gb,0h
		db 63h,	83h, 0Ah	;	  mov	  bc,[pp].0ah
		db 8Bh,	9Fh, 16h, 70h	;	  call	  [pp].16h,x3351
		db 31h,	30h, 2 dup(0)	; x32e1:  movi	  gb,0h
		db 0F1h, 30h, 80h, 0FEh	;	  movi	  mc,0fe80h
		db 11h,	30h, 0D0h, 0FFh	;	  movi	  ga,0ffd0h
		db 13h,	4Fh, 12h, 0, 2	;	  movi	  [pp].12h,200h
		db 0Ah,	0BBh, 4, 12h	;	  jnbt	  [pp].4h,0,x3308
		db 0D1h, 30h, 28h, 8Ah	;	  movi	  cc,8a28h
		db 0A0h, 0		;	  wid	  8,16
		db 6Ah,	0BBh, 4, 17h	;	  jnbt	  [pp].4h,3,x3317
		db 13h,	4Fh, 12h, 5, 2	;	  movi	  [pp].12h,205h
		db 88h,	20h, 0Fh	;	  jmp	  x3317
		db 0D1h, 30h, 28h, 56h	; x3308:  movi	  cc,5628h
		db 0C0h, 0		;	  wid	  16,8
		db 4Ah,	0BBh, 4, 5	;	  jnbt	  [pp].4h,2,x3317
		db 13h,	4Fh, 12h, 4, 0	;	  movi	  [pp].12h,4h
		db 63h,	83h, 12h	; x3317:  mov	  bc,[pp].12h
		db 2, 93h, 9, 0, 0CEh	;	  movb	  [gc],[pp].9h
		db 60h,	0		;	  xfer
		db 2, 93h, 4, 2, 0CEh, 6 ;	   movb	   [gc].6h,[pp].4h
		db 0Ah,	0B6h, 6, 33h	;	  jmcne	  [gc].6h,x335e
		db 2, 0EFh, 10h		;	  decb	  [pp].10h
		db 0Ah,	0E7h, 10h, 6	;	  jzb	  [pp].10h,x3338
		db 2, 0EBh, 9		;	  incb	  [pp].9h
		db 88h,	20h, 0DFh	;	  jmp	  x3317
		db 0Ah,	0BBh, 4, 0Eh	; x3338:  jnbt	  [pp].4h,0,x334a
		db 23h,	8Bh, 0Ch	;	  lpd	  gb,[pp].0ch
		db 11h,	30h, 2 dup(0)	;	  movi	  ga,0h
		db 63h,	83h, 0Ah	;	  mov	  bc,[pp].0ah
		db 8Bh,	9Fh, 16h, 7	;	  call	  [pp].16h,x3351
		db 0Ah,	4Fh, 5,	0	; x334a:  movbi	  [pp].5h,0h
		db 88h,	20h, 26h	;	  jmp	  x3377
		db 0E0h, 0		; x3351:  wid	  16,16
		db 0D1h, 30h, 8, 0C2h	;	  movi	  cc,0c208h
		db 60h,	0		;	  xfer
		db 2 dup(0)		;	  nop
		db 83h,	8Fh, 16h	;	  movp	  tp,[pp].16h
		db 2, 92h, 6, 2, 0CFh, 5 ; x335e:  movb	   [pp].5h,[gc].6h
		db 0Ah,	0CBh, 5, 7Eh	;	  andbi	  [pp].5h,7eh
		db 0E2h, 0F7h, 5	;	  setb	  [pp].5h,7
		db 0Ah,	4Eh, 6,	0	;	  movbi	  [gc].6h,0h
		db 88h,	20h, 5		;	  jmp	  x3377
		db 13h,	4Fh, 5,	81h, 0	; x3372:  movi	  [pp].5h,81h
		db 40h,	0		; x3377:  sintr
		db 20h,	48h		;	  hlt
		db 0FFh
		db 0FFh
		db 0EBh	dup(0)
MORE_DATA_ROM	db 0Ah
		db 'Press any key to interrupt boot',0Ah
		db 0,0Ah
		db 'Booting from Hard Disk',0,0Ah
		db 'Enter [1] to boot from Hard Disk',0Ah
		db 'Enter [2] to boot from Floppy Disk',0Ah
		db 'Enter [3] to enter Monitor',0Ah
		db 0Ah
		db 'Enter option: ',0,0Ah
		db '< A, B, D, G, I, K, L, M, O, R, S, X > ',0,0,0Ah
		db 'CS:IP ',0,'  Flags  ',0
PAD		db 0AA2h dup(0FFh)
ROM		ends

; ───────────────────────────────────────────────────────────────────────────
; ═══════════════════════════════════════════════════════════════════════════

; Segment type:	Regular
HIGH		segment	byte public '' use16
		assume cs:HIGH
		;org 0FFF0h
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
		jmp	far ptr	ENTRY_TRAMPOLINE
; ───────────────────────────────────────────────────────────────────────────
		db    0
IOP8089_FLAGS	IOP8089_SCP <1,	0FFh, 410h, 0>
		db 0FFh
		db 0FFh
		db 0FFh
		db 0FBh	; ¹
HIGH		ends


		end
